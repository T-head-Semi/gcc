#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import os
import sys

import re
import copy

from operator import itemgetter
from itertools import groupby

import math

scritp_version = "1.8.1"
scritp_dirname, script_filename = os.path.split(os.path.abspath(sys.argv[0]))


def expand_insn_segmem(insn):
    rets = []
    for i in range(7):
        i = str(i + 2)
        ci = copy.deepcopy(insn)
        ci["types"] = ci["types"].replace("@", i)
        ci["insn"] = map(lambda m: m.replace("@", i), ci["insn"])
        if "insnu" in ci.keys():
            ci["insnu"] = map(lambda m: m.replace("@", i), ci["insnu"])

        if "idoc" in ci.keys():
            ci["idoc"] = map(lambda m: m.replace("@", i), ci["idoc"])
        if "operation" in ci.keys():
            ci["operation"] = ci["operation"].replace("@", i)
        if "moperation" in ci.keys():
            ci["moperation"] = ci["moperation"].replace("@", i)
        if "attribute" not in ci:
            ci["attribute"] = {}
        ci["attribute"]["segmem_expand"] = ""
        rets.append(ci)
    return rets


def expand_insn_mask_max_args(insn):
    insn["types"] = insn["types"].replace("|8", "")
    return [insn]


def expand_insn_mem_types(insn, name):
    types = [
        (".*h", "u?int8"),
        (".*w", "u?int(8|16)"),
    ]

    x = insn["types"]

    for t in types:
        if re.match(t[0], name) and re.match(t[-1], x):
            return False

    return True


'''
name: 1. The name of builtin function, '__builtin_' will be added as prefix, and the ITYPE will be added as suffix.
      2. The name of inline function, the CTYPE will be added as suffix
      $insn means the name will get from insn
      $insn_mask means the name will get from insn and expand the mask format
prototype: The prototype of function, if the function has return value, the fisrt one will be the return type,
           if not the first one will be the first argument's type.
           In the prototype description, function can be called and it will be evaled, if the function is started
           with 'self.', it means it's a method of RvvBuiltins class. (FIXME To find a better way not use 'self.')
types: All the types the instruction suppurtted, can use regular expression to
       match types from type lists generated by RvvType.
itype: The type added as the calling builtin function name's suffix.
ctype: The type added as the function name suffix. The defualt is TYPE
insn: The instruction's name, if not defined, the default value is equal to NAME.
      It is a list and multiple instructions can be written because they can share
      other items of the table item.
insnu: Defined if the instructions have unsigned version.
insnc: Defined if the unsigned paramters should convert to signed when calling builtin function.
       1. "" mean all the unsigned paramters should be converted.
       2. "!arg1,!arg2" can exclude some unsigned paramters to be converted.
class: The instruction's category, if not define , the default value is Unknow.
       It's only used in document.
expand: The value is a function that will be called to expand the item ot multiple items.
expandi: The value is a function that will be called to expand the INSN to more items.
         The first argumnt is the current table item,
         the second argument is the current instruction'name when iterate the INSN.
expandvf: The argument name that need to be changed to scalar float type in the expanding.
expandvx: The argument name that need to be changed to scalar float type in the expanding.
expandvi: It has the following formats:
          1. ARG:N, ARG is the argument name that need to be changed to scalar float type in the expanding,
                    N is the param that will pass in testuite.
          2. ARG:signed:N, ARG and N are same as above.
                           signed means the argument is signed type.
          3. ARG@I@N, ARG and N are same as above.
                      I should be used when INSN has not only one instructions, and only one instruction
                      should be expanded, then I is the one's index.
mask: If defined and the value is True, mean the instructions are all mask instructions.
      Then if INSN is $insn_mask, it doesn't need to expand for mask.
operation: Used in document.
operation@xxx: The operation is used for one specified instruction 'xxx'.
moperation: Used in document.
moperation@xxx: The mask operation is used for one specified instruction 'xxx'.
idoc: Used in document, shown as instruction's subhead. If '@' is used in it, then it will be
      divided into two parts. First part is the subhead, and the second part will be used in
      OPERATION to replace the $idoc.


For every instruction discribed in the document contains four part:
Instruction: Instruction's name, come from INSN.
Prototypes: The builtin functions' prototypes, come from NAME and PROTOTYPE.
Operation: Come from OPERATION.
Masked prototypes: It will be shown if the instruction has support mask operation,
                   and it automaticly generated from NAME and PROTOTYPE.
Masked operation: It will be shown if the instruction has support mask operation,
                  and it come from moperation.


coperation: Used for emiting testsuite.
param: Used for emiting testsuite.
'''


builtins = [
    { "name"        : "$insn",
      "prototype"   : ["unsigned int", "unsigned int avl", "int vtype"],
      "insn"        : ["vsetvl"],
      "class"       : "@Vector configuration",
      "idoc"        : ["Change the granted vector length by vtype",],
      "operation"   :  "gvl = compute_vector_length(avl, vtype)\n"
                       "result = gvl"
    },

    { "name"        : "$insn",
      "prototype"   : ["unsigned int", "unsigned int avl", "const int sew", "const int lmul"],
      "param"       : "avl, RVV_E32, RVV_M2",
      "insn"        : ["vsetvli"],
      "class"       : "@Vector configuration",
      "idoc"        : ["Change the granted vector length",],
      "operation"   :  "gvl = compute_vector_length(avl, sew, lmul)\n"
                       "result = gvl"
    },

    { "name"        : "vsetvli_max",
      "prototype"   : ["unsigned int", "const int sew", "const int lmul"],
      "param"       : "RVV_E32, RVV_M2",
      "insn"        : ["vsetvli"],
      "class"       : "@Vector configuration",
      "idoc"        : ["Change the granted vector length",],
      "operation"   :  "gvl = compute_vector_length_max(sew, lmul)\n"
                       "result = gvl"
    },

    { "name"        : "velement_set",
      "prototype"   : ["$types", "$types dest", "const int index", "re.sub('m[0-9]','m1',$types) element"],
      "ftype"       : ["", "", "INDEX", ""],
      "types"       : "(u?int|float)[0-9]*xm[2-9]",
      "itype"       : "$types",
      "ctype"       : "$types",
      "insn"        : ["vmv.v.v/vse.v/optimized"],
      "insnc"       : "",
      "param"       : "dest, 0, element",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Set a vector register element",],
      "operation"   :  "dest[index] = element\n"
                       "ret = dest"
    },

    { "name"        : "velement_get",
      "prototype"   : ["re.sub('m[0-9]','m1',$types)", "$types source", "const int index"],
      "ftype"       : ["", "", "INDEX"],
      "types"       : "(u?int|float)[0-9]*xm[2-9]",
      "itype"       : "$types",
      "ctype"       : "$types",
      "insn"        : ["vmv.v.v/vle.v/optimized"],
      "insnc"       : "",
      "param"       : "source, 0",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Get a vector register element",],
      "operation"   :  "dest = source[index]"
    },

    { "name"        : "vseg_element_get",
      "prototype"   : ["re.sub('x[0-9]x','x',$types)", "$types source", "const int index"],
      "ftype"       : ["", "", "INDEX"],
      "types"       : "(u?int|float)[0-9]*x@xm+",
      "expand"      : expand_insn_segmem,
      "ctype"       : "$types",
      "insn"        : ["vmv.v.v/vle.v/vsse.v/optimized"],
      "param"       : "source, 0",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Get a vector element from segment type variable",],
      "operation"   :  "dest = source[index]",
      "attribute"   : {"fake_unsigned": ""}
    },

    { "name"        : "vseg_element_set",
      "prototype"   : ["$types", "$types dest", "const int index",  "re.sub('x[0-9]x','x',$types) element"],
      "ftype"       : ["", "", "INDEX", ""],
      "types"       : "(u?int|float)[0-9]*x@xm+",
      "expand"      : expand_insn_segmem,
      "ctype"       : "$types",
      "insn"        : ["vmv.v.v/vle.v/vlse.v/optimized"],
      "param"       : "dest, 0, element",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Set a vector element for segment type variable",],
      "operation"   :  "dest = source[index]",
      "attribute"   : {"fake_unsigned": ""}
    },

    # Vector Unit-Stride Loads and Stores
    # ===================================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vlb.v", "vlh.v", "vlw.v"],
      "insnu"       : ["vlbu.v", "vlhu.v", "vlwu.v"],
      "class"       : "Memory accesses",
      "idoc"        : ["Load 8b <$insnu>signed in memory to vector",
                       "Load 16b <$insnu>signed in memory to vector",
                       "Load 32b <$insnu>signed in memory to vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = load_element(address)\n"
                      "  address = address + 1\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = load_element(address)\n"
                      "    address = address + 1\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address",
                       "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "insn"        : ["vle.v"],
      "insnc"       : "",
      "class"       : "Memory accesses",
      "idoc"        : ["Load elements in memory to vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = load_element(address)\n"
                      "  address = address + SEW / 8\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = load_element(address)\n"
                      "    address = address + SEW / 8\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "$types a", "$types.replace('uint', 'e').replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vsb.v", "vsh.v", "vsw.v"],
      "insnc"       : "",
      "return"      : False,
      "class"       : "Memory accesses",
      "idoc"        : ["Store 8b in memory from vector",
                       "Store 16b in memory from vector",
                       "Store 32b in memory from vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  store_element(address, a[element])\n"
                      "  address = address + 1",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "if mask[element] then\n"
                      "  store_element(address, a[element])\n"
                      "  address = address + 1",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "$types a",\
                       "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "insn"        : ["vse.v"],
      "insnc"       : "",
      "return"      : False,
      "class"       : "Memory accesses",
      "idoc"        : ["Store elements in memory from vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  store_element(address, a[element])\n"
                      "  address = address + SEW / 8",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "if mask[element] then\n"
                      "  store_element(address, a[element])\n"
                      "  address = address + SEW / 8",
    },

    # Vector Strided Instructions
    # ===========================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "long stride", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vlsb.v", "vlsh.v", "vlsw.v"],
      "insnu"       : ["vlsbu.v", "vlshu.v", "vlswu.v"],
      "class"       : "Memory accesses",
      "idoc"        : ["Load strided 8b <$insnu>signed in memory to vector",
                       "Load strided 16b <$insnu>signed in memory to vector",
                       "Load strided 32b <$insnu>signed in memory to vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = load_element(address)\n"
                      "  address = address + stride\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = load_element(address)\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "  address = address + stride\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "long stride",
                       "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "insn"        : ["vlse.v"],
      "insnc"       : "",
      "class"       : "Memory accesses",
      "idoc"        : ["Load strided elements in memory to vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = load_element(address)\n"
                      "  address = address + stride\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = load_element(address)\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "  address = address + stride\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "long stride", "$types a", "$types.replace('uint', 'e').replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vssb.v", "vssh.v", "vssw.v"],
      "insnc"       : "",
      "return"      : False,
      "class"       : "Memory accesses",
      "idoc"        : ["Store 8b in strided memory from vector",
                       "Store 16b in strided memory from vector",
                       "Store 32b in strided memory from vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  store_element(address, a[element])\n"
                      "  address = address + stride",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    store_element(address, a[element])\n"
                      "  address = address + stride",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "long stride", "$types a", "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "insn"        : ["vsse.v"],
      "insnc"       : "",
      "return"      : False,
      "class"       : "Memory accesses",
      "idoc"        : ["Store elements in strided memory from vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  store_element(address, a[element])\n"
                      "  address = address + stride",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    store_element(address, a[element])\n"
                      "  address = address + stride",
    },

    # Vector Indexed Instructions
    # ===========================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "$types index", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vlxb.v", "vlxh.v", "vlxw.v"],
      "insnu"       : ["vlxbu.v", "vlxhu.v", "vlxwu.v"],
      "class"       : "Memory accesses",
      "idoc"        : ["Load indexed 8b <$insnu>signed in memory to vector",
                       "Load indexed 16b <$insnu>signed in memory to vector",
                       "Load indexed 32b <$insnu>signed in memory to vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = load_element(address + index[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "result[gvl : VLMAX] = 0\n"
                      "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = load_element(address + index[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "$types.replace('float','int') index",
                       "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "ctype"       : "$types",
      "insn"        : ["vlxe.v"],
      "insnc"       : "",
      "class"       : "Memory accesses",
      "idoc"        : ["Load indexed element in memory to vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = load_element(address + index[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "result[gvl : VLMAX] = 0\n"
                      "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = load_element(address + index[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "$types index", "$types a", "$types.replace('uint', 'e').replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vsxb.v", "vsuxb.v", "vsxh.v", "vsuxh.v", "vsxw.v", "vsuxw.v"],
      "insnc"       : "",
      "return"      : False,
      "class"       : "Memory accesses",
      "idoc"        : ["Store 8b in ordered-indexed memory from vector",
                       "Store 8b in unordered-indexed memory from vector",
                       "Store 16b in ordered-indexed memory from vector",
                       "Store 16b in unordered-indexed memory from vector",
                       "Store 32b in ordered-indexed memory from vector",
                       "Store 32b in unordered-indexed memory from vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  store_element(address + index[element], a[element])",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    store_element(address + index[element], a[element])",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "$types.replace('float','int') index", "$types a", "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "ctype"       : "$types",
      "insn"        : ["vsxe.v", "vsuxe.v"],
      "insnc"       : "",
      "return"      : False,
      "class"       : "Memory accesses",
      "idoc"        : ["Store element in ordered-indexed memory from vector",
                       "Store element in unordered-indexed memory from vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  store_element(address + index[element], a[element])",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    store_element(address + index[element], a[element])",
    },

    # Vector Integer Comparison Instructions
    # ======================================

    { "name"        : "$insn_mask",
      "prototype"   : ["re.sub('u?int','e',$types)", "re.sub('u?int','e',$types) merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask",\
                       "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "itype"       : ["$types", "re.sub('u?int','e',$types)"],
      "insn"        : ["vmseq.vv", "vmsne.vv"],
      "insnc"       : "",
      "expandvx"    : "b",
      "expandvi"    : "b:signed:1",
      "class"       : "Integer relational operations",
      "idoc"        : ["Compare elementwise @vv for equality@==",
                       "Compare elementwise @vv for inequality@!=",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["re.sub('u?int','e',$types)", "re.sub('u?int','e',$types) merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask", \
                       "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "itype"       : ["$types", "re.sub('u?int','e',$types)"],
      "insn"        : ["vmslt.vv", "vmsle.vv"],
      "insnu"       : ["vmsltu.vv", "vmsleu.vv"],
      "expandvx"    : "b",
      "class"       : "Integer relational operations",
      "idoc"        : ["Compare elementwise @vv for lower-than@<",
                       "Compare elementwise @vv for lower-than-or-equal@<=",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["re.sub('u?int','e',$types)", "re.sub('u?int','e',$types) merge", "$types a", "self.get_element_ctype($types) b",\
                       "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "itype"       : ["$types", "re.sub('u?int','e',$types)"],
      "insn"        : ["vmsgt.vx", "vmsge.vx"],
      "insnu"       : ["vmsgtu.vx", "vmsgeu.vx"],
      "class"       : "Integer relational operations",
      "idoc"        : ["Compare elementwise <$insnu>signed integer one vector and one scalar for greater-than@>",
                       "Compare elementwise <$insnu>signed integer one vector and one scalar for greater-than-or-equal@>=",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["re.sub('u?int','e',$types)", "re.sub('u?int','e',$types) merge", "$types a", "const self.get_element_ctype($types) b",\
                       "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "itype"       : ["$types", "re.sub('u?int','e',$types)"],
      "insn"        : ["vmsle.vi", "vmsgt.vi"],
      "insnu"       : ["vmsleu.vi", "vmsgtu.vi"],
      "param"       : "merge, a, 1, mask, gvl",
      "class"       : "Integer relational operations",
      "idoc"        : ["Compare elementwise <$insnu>signed integer one vector and one scalar immediate for lower-than-or-equal@<=",
                       "Compare elementwise <$insnu>signed integer one vector and one scalar immediate for greater-than@>",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    # Vector Mask Instructions
    # ========================

    { "name"        : "$insn",
      "prototype"   : ["$types", "$types a", "$types b", "unsigned int gvl"],
      "types"       : "e[0-9]*xm+",
      "itype"       : ["$types.replace('e','int')", "$types"],
      "insn"        : ["vmand.mm", "vmnand.mm", "vmandnot.mm", "vmxor.mm",
                       "vmor.mm", "vmnor.mm", "vmornot.mm", "vmxnor.mm"],
      "class"       : "Operations with masks",
      "idoc"        : ["Compute elementwise logical and between two masks@logical_and",
                       "Compute elementwise logical negated and between two masks@logical_nand",
                       "Compute elementwise logical andnot between two masks@logical_andnot",
                       "Compute elementwise logical xor between two masks@logical_xor",
                       "Compute elementwise logical or between two masks@logical_or",
                       "Compute elementwise logical negated or between two masks@logical_nor",
                       "Compute elementwise logical ornot between two masks@logical_ornot",
                       "Compute elementwise logical xnor between two masks@logical_xnor",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b[element])\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "$types a", "unsigned int gvl"],
      "types"       : "e[0-9]*xm+",
      "itype"       : ["$types.replace('e','int')", "$types"],
      "insn"        : ["vmcpy.m", "vmnot.m"],
      "class"       : "Operations with masks",
      "idoc"        : ["Copy elementwise mask@logical_cpy",
                       "Invert elementwise mask@logical_not",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element])\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "unsigned int gvl"],
      "types"       : "e[0-9]*xm+",
      "itype"       : ["$types.replace('e','int')", "$types"],
      "insn"        : ["vmclr.m", "vmset.m"],
      "class"       : "Operations with masks",
      "idoc"        : ["Clear elementwise mask@logical_clr",
                       "Set elementwise mask@logical_set",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (result[element])\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["unsigned long", "$types a", "$types mask", "unsigned int gvl"],
      "types"       : "e[0-9]*xm+",
      "itype"       : "$types.replace('e','int')",
      "insn"        : ["vmpopc.m"],
      "class"       : "Operations with masks",
      "idoc"        : ["Population count of a mask vector"],
      "operation"   :  "result = 0\n"
                       "for element = 0 to gvl - 1\n"
                       "  if a[element] then\n"
                       "    result = result + 1",
      "moperation"   :  "result = 0\n"
                        "for element = 0 to gvl - 1\n"
                        "  if  mask[element] and a[element] then\n"
                        "    result = result + 1",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["long", "$types a", "$types mask", "unsigned int gvl"],
      "types"       : "e[0-9]*xm+",
      "itype"       : "$types.replace('e','int')",
      "insn"        : ["vmfirst.m"],
      "class"       : "Operations with masks",
      "idoc"        : ["Compute the index of the first enabled element"],
      "operation" : "result = -1\n"
                    "for element = 0 to gvl - 1\n"
                    "  if a[element]\n"
                    "    result = element\n"
                    "    break",
      "moperation" : "result = -1\n"
                     "for element = 0 to gvl - 1\n"
                     "  if mask[element] and a[element] then\n"
                     "    result = element\n"
                     "    break"
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types a", "$types mask", "unsigned int gvl"],
      "types"       : "e[0-9]*xm+",
      "itype"       : ["$types.replace('e','int')", "$types"],
      "insn"        : ["vmsbf.m", "vmsif.m", "vmsof.m"],
      "class"       : "Operations with masks",
      "idoc"        : ["Enable elements beforte the first one enabled",
                       "Enable elements until the first one enabled",
                       "Enable only the first element enabled"],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  if not a[element] then\n"
                       "    result[element] = 1\n"
                       "  else\n"
                       "    break\n"
                       "result[element : VLMAX] = 0",
      "moperation"   :  "for element = 0 to gvl - 1\n"
                        "  if mask[element] then\n"
                        "    if not a[element] then\n"
                        "      result[element] = 1\n"
                        "    else\n"
                        "      break\n"
                        "result[element : VLMAX] = 0",
      "operation@vmsif.m"   :  "for element = 0 to gvl - 1\n"
                               "  result[element] = 1\n"
                               "  if a[element] then\n"
                               "    break\n"
                               "result[element : VLMAX] = 0",
      "moperation@vmsif.m"   :  "for element = 0 to gvl - 1\n"
                                "  if mask[element] then\n"
                                "    result[element] = 1\n"
                                "    if a[element] then\n"
                                "      break\n"
                                "result[element : VLMAX] = 0",
      "operation@vmsof.m"   :  "for element = 0 to gvl - 1\n"
                               "  if a[element] then\n"
                               "    result[element] = 1\n"
                               "    break\n"
                               "  else\n"
                               "    result[element] = 0\n"
                               "result[element : VLMAX] = 0",
      "moperation@vmsof.m"   :  "for element = 0 to gvl - 1\n"
                                "  if mask[element] then\n"
                                "    if a[element] then\n"
                                "      result[element] = 1\n"
                                "      break\n"
                                "    else\n"
                                "      result[element] = 0\n"
                                "result[element : VLMAX] = 0",
    },

    # Vector Bitwise Logical Instructions
    # ===================================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vand.vv", "vor.vv", "vxor.vv"],
      "insnc"       : "",
      "expandvx"    : "b",
      "expandvi"    : "b:signed:1",
      "class"       : "Bit manipulation",
      "idoc"        : ["Elementwise @vv bitwise-and@bitwise_and",
                       "Elementwise @vv bitwise-or@bitwise_or",
                       "Elementwise @vv bitwise-xor@bitwise_xor",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element], b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "coperation"  : ["return a & b;", "return a | b;", "return a ^ b;"]
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vnot.v"],
      "insnc"       : "",
      "class"       : "Bit manipulation",
      "idoc"        : ["Elementwise vector bitwise-not@bitwise_not",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types.replace('int', 'uint') b", "$types.replace('int', 'e') mask", \
                       "unsigned int gvl"],
      "types"       : "int[0-9]*xm+",
      "insn"        : ["vsra.vv"],
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Bit manipulation",
      "idoc"        : ["Elementwise @vv arithmetic shift right@sra",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element], b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "coperation"  : ["return a >> b;"]
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "re.sub('u?int','uint',$types) b", "re.sub('u?int','e',$types) mask", \
                       "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vsll.vv"],
      "insnc"       : "!b",
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Bit manipulation",
      "idoc"        : ["Elementwise @vv logic shift left@sll",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element], b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "coperation"  : ["return a << b;"]
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "$types.replace('uint', 'e') mask", "unsigned int gvl"],
      "types"       : "uint[0-9]*xm+",
      "insn"        : ["vsrl.vv"],
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Bit manipulation",
      "idoc"        : ["Elementwise @vv logic shift right@srl",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element], b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "coperation"  : ["return a >> b;"]
    },

    # Vector Integer Arithmetic Instructions
    # ======================================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types ", "$types merge", "self.double_ctype($types) a", "$types b", \
                       "self.double_ctype($types).replace('uint', 'e') mask", "unsigned int gvl"],
      "types"       : "uint(32|16|8)xm(1|2|4)_t",
      "itype"       : "self.double_ctype($types)",
      "insn"        : ["vnsrl.vv"],
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Narrowing elementwise @vv logic shift right@srl",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = narrow_int ($idoc (a[element], b[element]))\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = narrow_int ($idoc (a[element], b[element]))\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types ", "$types merge", "self.double_ctype($types) a", "$types.replace('int', 'uint') b", \
                       "self.double_ctype($types).replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "int(32|16|8)xm(1|2|4)_t",
      "itype"       : "self.double_ctype($types)",
      "insn"        : ["vnsra.vv"],
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Narrowing elementwise @vv arithmetic shift right@sra",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = narrow_int ($idoc (a[element], b[element]))\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = narrow_int ($idoc (a[element], b[element]))\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vadd.vv", "vsub.vv", "vmul.vv", "vdot.vv"],
      "insnc"       : "",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise vector-vector integer addtion@+",
                       "Elementwise vector-vector integer subtraction@-",
                       "Elementwise vector-vector integer multiplication@*",
                       "Elementwise vector-vector integer dot-product"],
      "operation@vdot.vv" : "for element = 0 to gvl - 1\n"
                            "  result[element] = dot-product(a[element], b[element])\n"
                            "result[gvl : VLMAX] = 0",
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vdot.vv" : "for element = 0 to gvl - 1\n"
                             "  if mask[element] then\n"
                             "    result[element] = dot-product(a[element], b[element])\n"
                             "  else\n"
                             "    result[element] = merge[element]\n"
                             "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "coperation"  : ["return a + b;", "return a - b;","return a * b;"]
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types a", "$types b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "mask"        : True,
      "insn"        : ["vadc.vvm", "vsbc.vvm"],
      "expandvx"    : "b",
      "insnc"       : "",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv integer addtion with carry@+",
                       "Elementwise @vv integer addtion with borrow@-"],
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b[element] $idoc mask[elemet]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["re.sub('u?int','e',$types)", "$types a", "$types b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "itype"       : ["$types", "re.sub('u?int','e',$types)"],
      "mask"        : True,
      "insn"        : ["vmadc.vvm", "vmsbc.vvm"],
      "expandvx"    : "b",
      "insnc"       : "",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv integer addtion with carry in mask register format",
                       "Elementwise @vv integer addtion with borrow in mask register format"],
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  result[element] = carry_out(a[element] + b[element] + mask[elemet])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vmsbc.vvm"  :  "for element = 0 to gvl - 1\n"
                       "  result[element] = borrow_out(a[element] - b[element] - mask[elemet])\n"
                       "result[gvl : VLMAX] = 0",

    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types a", "const int b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "mask"        : True,
      "insn"        : ["vadc.vim"],
      "param"       : "a, 1, mask, gvl",
      "insnc"       : "",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise vector-immediate integer addtion with carry"],
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] + b + mask[elemet]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["re.sub('u?int','e',$types)", "$types a", "const int b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "itype"       : ["$types", "re.sub('u?int','e',$types)"],
      "mask"        : True,
      "insn"        : ["vmadc.vim"],
      "param"       : "a, 1, mask, gvl",
      "insnc"       : "",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise vector-immediate integer addtion with carry in mask register format"],
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  result[element] = carry_out(a[element] + b + mask[elemet])\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vsadd.vv", "vssub.vv"],
      "insnu"       : ["vsaddu.vv", "vssubu.vv"],
      "expandvx"    : "b",
      "expandvi"    : "b@0:1",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv addtion with saturation@+",
                       "Elementwise @vv substraction with saturation@-"],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = saturat(a[element] $idoc b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = saturat(a[element] $idoc b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "$types.replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "int[0-9]*xm+",
      "insn"        : ["vaadd.vv", "vasub.vv"],
      "expandvx"    : "b",
      "expandvi"    : "b@0:1",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv integer averge add@+",
                       "Elementwise @vv integer averge sub@-"],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = (a[element] $idoc b[element])/2\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = (a[element] $idoc b[element])/2\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "$types.replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "int[0-9]*xm+",
      "insn"        : ["vsmul.vv"],
      "expandvx"    : "b",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv multiply with rounding and saturation"],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = clip(roundoff(a[element] * b[element], SEW - 1))\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = clip(roundoff(a[element] * b[element], SEW - 1))\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "re.sub('u?int','uint',$types) b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vssra.vv"],
      "insnu"       : ["vssrl.vv"],
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv <$insnu>signed scaling shift"],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = (a[elemet] + (1 << b[element] - 1)) >> b[elemet]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = (a[elemet] + (1 << b[element] - 1)) >> b[elemet]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "self.double_ctype($types) a", "re.sub('u?int','uint',$types) b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int(8|16|32)xm(1|2|4)",
      "itype"       : "self.double_ctype($types)",
      "insn"        : ["vnclip.vv"],
      "insnu"       : ["vnclipu.vv"],
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv <$insnu>signed integer narrow clip"],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = clip(roundoff(a[element], b[element]))\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = clip(roundoff(a[element], b[element]))\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "$types result", "re.sub('u?int','e',$types) mask", \
                       "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm(1|2|4|8)",
      "insn"        : ["vmacc.vv", "vnmsac.vv", "vmadd.vv", "vnmsub.vv"],
      "insnc"       : "",
      "expandvx"    : "a",
      "expandm"     : expand_insn_mask_max_args,
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv muiltiply-addition, overwrite addend",
                       "Elementwise @vv muiltiply-subtarction, overwrite minuend",
                       "Elementwise @vv muiltiply-addition, overwrite multiplicand",
                       "Elementwise @vv muiltiply-subtarction, overwrite multiplicand",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = +(a[element] * b[element]) + result[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"   : "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "  result[element] = +(a[element] * b[element]) + result[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vnmsac.vv"   :
                       "for element = 0 to gvl - 1\n"
                       "  result[element] = -(a[element] * b[element]) + result[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vnmsac.vv"   :
                       "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "  result[element] = -(a[element] * b[element]) + result[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vmadd.vv"   :
                       "for element = 0 to gvl - 1\n"
                       "  result[element] = +(a[element] * result[element]) + b[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vmadd.vv"   :
                       "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "  result[element] = +(a[element] * result[element]) + b[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vnmsub.vv"   :
                       "for element = 0 to gvl - 1\n"
                       "  result[element] = -(a[element] * result[element]) + b[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vnmsub.vv"   :
                       "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "  result[element] = -(a[element] * result[element]) + b[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask",
                       "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vdiv.vv", "vrem.vv", "vmin.vv", "vmax.vv", "vmulh.vv"],
      "insnu"       : ["vdivu.vv", "vremu.vv", "vminu.vv", "vmaxu.vv", "vmulhu.vv"],
      "expandvx"    : "b",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv division@/",
                       "Elementwise @vv division remainder@rem",
                       "Elementwise @vv minumim@min",
                       "Elementwise @vv maximum@max",
                       "Elementwise @vv multiplication(higher bits)@mulh",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element], b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vdivu.vv,vdiv.vv"   :
                       "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vdivu.vv,vdiv.vv"  :
                       "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "coperation"  : ["return a / b;", "return a % b;"]
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types.replace('int', 'uint') b", "$types.replace('int', 'e') mask",\
                       "unsigned int gvl"],
      "types"       : "int[0-9]*xm+",
      "insn"        : ["vmulhsu.vv"],
      "expandvx"    : "b",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise @vv signed-unsigned integer multiplication(higher bits)@mulhsu",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element], b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "self.get_element_ctype($types) b", "re.sub('u?int','e',$types) mask", \
                       "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vadd.vx", "vsub.vx", "vrsub.vx"],
      "insnc"       : "",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise vector-scalar integer addtion@+",
                       "Elementwise vector-scalar integer subtraction@-",
                       "Elementwise vector-scalar integer reverse subtraction@rsub",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vrsub.vx"   :
                       "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b)\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vrsub.vx"  :
                       "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element], b)\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "self.get_element_ctype($types) b", "$types.replace('int', 'e') mask", \
                       "unsigned int gvl"],
      "types"       : "int[0-9]*xm+",
      "insn"        : ["vmul.vx"],
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise vector-scalar integer multiplication@x",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "const self.get_element_ctype($types) b", "re.sub('u?int','e',$types) mask", \
                       "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vadd.vi", "vrsub.vi"],
      "param"       : "merge, a, 1, mask, gvl",
      "insnc"       : "",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Elementwise vector-immediate integer addtion@+",
                       "Elementwise vector-immediate integer reverse subtraction@rsub",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc b\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc b\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vrsub.vi"   :
                       "for element = 0 to gvl - 1\n"
                       "  result[element] = $idoc (a[element], b)\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vrsub.vi"  :
                       "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = $idoc (a[element], b)\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask",\
                       "unsigned int gvl"],
      "types"       : "u?int(8|16|32)xm(1|2|4)_t",
      "itype"       : "$types",
      "insn"        : ["vwadd.vv", "vwsub.vv", "vwmul.vv"],
      "insnu"       : ["vwaddu.vv", "vwsubu.vv", "vwmulu.vv"],
      "expandvx"    : "b",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Widening elementwise @vv addition@+",
                       "Widening elementwise @vv subtraction@-",
                       "Widening elementwise @vv multiplition@*",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = widen_integer (a[element]) $idoc widen_integer (b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = widen_integer (a[element]) $idoc widen_integer (b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "$types a", "$types b", "self.double_ctype($types) result", \
                       "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int(8|16|32)xm(1|2|4)_t",
      "itype"       : "$types",
      "insn"        : ["vwmacc.vv", "vwsmacc.vv"],
      "insnu"       : ["vwmaccu.vv", "vwsmaccu.vv"],
      "expandvx"    : "a",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Widening elementwise @vv multiply-add, overwrite addend",
                       "Widening elementwise @vv multiply-add, overwrite addend, with round and saturation"],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = +widen_integer(a[element] * b[element]) + result[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = +widen_integer(a[element] * b[element]) + result[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vwsmacc.vv"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = clip(((a[elemet] * b[elemet] + round) >> (sew / 2)) + result[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vwsmacc.vv"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = clip(((a[elemet] * b[elemet] + round) >> (sew / 2)) + result[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "self.double_ctype($types) a", "$types b", \
                       "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int(8|16|32)xm(1|2|4)_t",
      "itype"       : "$types",
      "insn"        : ["vwadd.wv", "vwsub.wv"],
      "insnu"       : ["vwaddu.wv", "vwsubu.wv"],
      "expandvx"    : "b",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Widening elementwise (Widening)@vv addition@+",
                       "Widening elementwise (Widening)@vv subtraction@-",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element] $idoc widen_integer (b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = a[element] $idoc widen_integer (b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "$types a", "$types.replace('int', 'uint') b", \
                       "$types.replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "int(8|16|32)xm(1|2|4)_t",
      "itype"       : "$types",
      "insn"        : ["vwmulsu.vv"],
      "expandvx"    : "b",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Widening elementwise @vv signed-unsigned integer multiplication@*",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = widen_integer (a[element] $idoc b[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = widen_integer (a[element] $idoc b[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "$types a", "$types.replace('int', 'uint') b", \
                       "self.double_ctype($types) result", "$types.replace('int', 'e') mask", \
                       "unsigned int gvl"],
      "types"       : "int(8|16|32)xm(1|2|4)_t",
      "itype"       : "$types",
      "insn"        : ["vwmaccsu.vv", "vwsmaccsu.vv"],
      "expandvx"    : "a",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Widening elementwise @vv signed-unsigned integer multiply-sub, overwrite addend",
                       "Widening elementwise @vv signed-unsigned integer multiply-sub, overwrite addend, with round and satruation"],
      "operation"   :
                       "for element = 0 to gvl - 1\n"
                       "  result[element] = +widen_integer (a[element] * b[element]) + result[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :
                       "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = +widen_integer (a[element] * b[element]) + result[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vwsmaccsu.vv"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = clip(((a[element] * b[elemet] + round) >> (sew / 2)) + result[element])\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vwsmaccsu.vv"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = clip(((a[element] * b[elemet] + round) >> (sew / 2)) + result[element])\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "self.get_element_ctype($types.replace('int', 'uint')) a", "$types b", \
                       "self.double_ctype($types) result", "$types.replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "int(8|16|32)xm(1|2|4)_t",
      "itype"       : "$types",
      "insn"        : ["vwmaccus.vx", "vwsmaccus.vx"],
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Widening elementwise vector-scalar unsigned-signed integer multiply-sub, overwrite addend",
                       "Widening elementwise vector-scalar unsigned-signed integer multiply-sub, overwrite addend, with round and saturation"],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  result[element] = +widen_integer (a * b[element]) + result[element]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = +widen_integer (a * b[element]) + result[element]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vwsmaccus.vx"   :  "for element = 0 to gvl - 1\n"
                                    "  result[element] = clip(((a * b[elemet] + round) >> (sew / 2)) + result[element])\n"
                                    "result[gvl : VLMAX] = 0",
      "moperation@vwsmaccus.vx"  :  "for element = 0 to gvl - 1\n"
                                    "  if mask[element] then\n"
                                    "    result[element] = clip(((a * b[elemet] + round) >> (sew / 2)) + result[element])\n"
                                    "  else\n"
                                    "    result[element] = merge[element]\n"
                                    "result[gvl : VLMAX] = 0",
    },

    # Vector Reduction Operations
    # ===========================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vredsum.vs", "vredand.vs", "vredor.vs", "vredxor.vs"],
      "insnc"       : "",
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Integer vector sum reduction@sum",
                       "Integer vector bitwise-and reduction@bitwise_and",
                       "Integer vector bitwise-or reduction@bitwise_or",
                       "Integer vector bitwise-xor reduction@bitwise_xor",],
      "operation"   :  "if gvl > 0:\n"
                       "  current_red = b[0]\n"
                       "  for element = 0 to gvl - 1\n"
                       "    current_red = $idoc (current_red, a[element])\n"
                       "result[0] = current_red\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "if gvl > 0:\n"
                       "  current_red = b[0]\n"
                       "  for element = 0 to gvl - 1\n"
                       "    if mask[element] then\n"
                       "      current_red = $idoc (current_red, a[element])\n"
                       "    else\n"
                       "      result[element] = merge[element]\n"
                       "result[0] = current_red\n"
                       "result[1 : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vredmax.vs", "vredmin.vs"],
      "insnu"       : ["vredmaxu.vs", "vredminu.vs"],
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Integer vector <$insnu>signed maximum reduction@max",
                       "Integer vector <$insnu>signed minimum reduction@min",],
      "operation"   :  "if gvl > 0:\n"
                       "  current_red = b[0]\n"
                       "  for element = 0 to gvl - 1\n"
                       "    current_red = $idoc (current_red, a[element])\n"
                       "result[0] = current_red\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "if gvl > 0:\n"
                       "  current_red = b[0]\n"
                       "  for element = 0 to gvl - 1\n"
                       "    if mask[element] then\n"
                       "      current_red = $idoc (current_red, a[element])\n"
                       "    else\n"
                       "      result[element] = merge[element]\n"
                       "result[0] = current_red\n"
                       "result[1 : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "$types a", "self.double_ctype($types) b", \
                       "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int(8|16|32)xm(1|2|4)_t",
      "itype"       : "$types",
      "insn"        : ["vwredsum.vs"],
      "insnu"       : ["vwredsumu.vs"],
      "class"       : "Integer arithmetic operations",
      "idoc"        : ["Widening <$insnu>signed integer vector sum reduction@sum",],
      "operation"   :  "if gvl > 0:\n"
                       "  current_red = b[0]\n"
                       "  for element = 0 to gvl - 1\n"
                       "    current_red = $idoc (current_red, widen_integer (a[element]))\n"
                       "result[0] = current_red\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "if gvl > 0:\n"
                       "  current_red = b[0]\n"
                       "  for element = 0 to gvl - 1\n"
                       "    if mask[element] then\n"
                       "      current_red = $idoc (current_red, widen_integer (a[element]))\n"
                       "    else\n"
                       "      result[element] = merge[element]\n"
                       "result[0] = current_red\n"
                       "result[1 : VLMAX] = 0",
    },

    # Vector Permutation Instructions
    # ===============================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "re.sub('(u?int|float)','uint',$types) b",\
                       "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "insn"        : ["vrgather.vv"],
      "insnc"       : "!b",
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Gather @vv (index)",],
      "operation"   :  "for element = 0 to gvl - 1\n"
                       "  if b[element] > VLMAX then\n"
                       "    result[elemnt] = 0\n"
                       "  else\n"
                       "    result[element] = a[b[element]]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    if b[element] > VLMAX then\n"
                       "      result[elemnt] = 0\n"
                       "    else\n"
                       "      result[element] = a[b[element]]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "long b", \
                       "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "insn"        : ["vslideup.vx", "vslidedown.vx"],
      "insnc"       : "!b",
      "expandvi"    : "b:1",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Slide up elements of @vx (indexed)",
                       "Slide down elements of @vx (indexed)",],
      "operation"   :  "for element = b to gvl - 1\n"
                       "  if element - b < 0\n"
                       "    result[element] = result[element]\n"
                       "  else"
                       "    result[element] = a[element - b]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation"  :  "for element = 0 to gvl - 1\n"
                       "  if mask[element] and element -b >= 0 then\n"
                       "    result[element] = a[element - b]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vslidedown.vx"   :
                       "for element = b to gvl - 1\n"
                       "  if element + b < VLMAX then\n"
                       "     result[element] = a[element + b]\n"
                       "  else\n"
                       "     result[element] = 0\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vslidedown.vx"  :
                       "for element = b to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    if element + b < VLMAX then\n"
                       "      result[element] = a[element + b]\n"
                       "    else\n"
                       "      result[element] = 0\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "long b", \
                       "re.sub('(u?int|float)','e',$types) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "insn"        : ["vslide1up.vx", "vslide1down.vx"],
      "insnc"       : "",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Slide up one element of a vector",
                       "Slide down one element of a vector"],
      "operation@vslide1up.vx"   :
                       "for element = 0 to gvl - 1\n"
                       "  if element == 0 then\n"
                       "    result[0] = b\n"
                       "  else\n"
                       "    result[element] = a[element - 1]\n"
                       "result[gvl : VLMAX] = 0",
      "moperation@vslide1up.vx"  :
                       "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    if element == 0 then result[element] = b\n"
                       "    else\n"
                       "      result[element] = a[element - 1]\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
      "operation@vslide1down.vx"   :
                       "for element = b to gvl - 1\n"
                       "  if element == gvl - 1 then result[element] = b\n"
                       "  else if element + 1 < VLMAX then\n"
                       "     result[element] = a[element + 1]\n"
                       "  else\n"
                       "     result[element] = 0\n"
                       "result[gvl : VLMAX] = 0",
      "moperationvslide1down.vx"  :
                       "for element = b to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    if element == gvl - 1 then result[element] = b\n"
                       "    else if element + 1 < VLMAX then\n"
                       "      result[element] = a[element + 1]\n"
                       "    else\n"
                       "      result[element] = 0\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "$types a", "re.sub('u?int','e',$types) b", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vcompress.vm"],
      "insnc"       : "",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Pack elements contiguously",],
      "operation"   : "next_index = 0\n"
                      "for element = 0 to gvl - 1\n"
                      " if b[element] then\n"
                      "   result[next_index] = a[element]\n"
                      "   next_index = next_index + 1\n"
                      "result[next_index : VLMAX] = 0"
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types.replace('uint', 'e') a", "$types.replace('uint', 'e') mask",\
                       "unsigned int gvl"],
      "types"       : "uint[0-9]*xm+",
      "insn"        : ["viota.m"],
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Compute a prefix sum of a mask",],
      "operation"   : "prefix_sum = 0\n"
                      "for element = 0 to gvl - 1\n"
                      "  result[element] = prefix_sum\n"
                      "  if a[element] then\n"
                      "    prefix_sum = prefix_sum + 1\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"   : "prefix_sum = 0\n"
                      "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = prefix_sum\n"
                      "    if a[element] then\n"
                      "      prefix_sum = prefix_sum + 1\n"
                      "  else\n"
                      "      result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
      },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types.replace('uint', 'e') mask", "unsigned int gvl"],
      "types"       : "uint[0-9]*xm+",
      "insn"        : ["vid.v"],
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Compute index vector",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = element\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"   : "for element = 0 to gvl - 1\n"
                       "  if mask[element] then\n"
                       "    result[element] = element\n"
                       "  else\n"
                       "    result[element] = merge[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types a", "$types b", "re.sub('u?int','e',$types) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vmerge.vvm"],
      "mask"        : True,
      "insnc"       : "",
      "expandvx"    : "b",
      "expandvi"    : "b:1",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Elementwise @vv integer merge",],
      "moperation"   : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = b[element]\n"
                      "  else\n"
                      "    result[element] = a[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "$types a", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*xm+",
      "insn"        : ["vmv.v.v"],
      "insnc"       : "",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Elementwise vector integer move",],
      "operation"   : "for element = 0 to gvl - 1\n"
                       "  result[element] = a[element]\n"
                       "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "self.get_element_ctype($types) a", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vmv.v.x"],
      "insnc"       : "",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Elementwise scalar integer move",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = a\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "const self.get_element_ctype($types) a", "unsigned int gvl"],
      "types"       : "int[0-9]*xm+",
      "insn"        : ["vmv.v.i"],
      "param"       : "1, gvl",
      "insnc"       : "",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Elementwise immediate integer move",],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = a\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["self.get_element_ctype($types)", "$types a", "unsigned int b", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vext.x.v"],
      "insnc"       : "",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Extract integer element",],
      "operation"   : "if b < VLEN/SEW\n"
                      "  result = a[b]\n"
                      "else\n"
                      "  result = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "self.get_element_ctype($types) a", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vmv.s.x"],
      "insnc"       : "",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Set first integer element of integer vector",],
      "operation"   : "result[0] = a",
    },

    { "name"        : "$insn",
      "prototype"   : ["self.get_element_ctype($types)", "$types a", "unsigned int gvl"],
      "types"       : "u?int[0-9]*xm+",
      "insn"        : ["vmv.x.s"],
      "insnc"       : "",
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Get first integer element of integer vector",],
      "operation"   : "result = a[0]",
    },

    # Vector Floating-Point Instructions
    # ==================================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types.replace('float', 'int') a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "insn"        : ["vfcvt.f.x.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert interger to floating-point"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = int_to_fp(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = int_to_fp(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types.replace('float', 'uint') a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "insn"        : ["vfcvt.f.xu.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert unsigned interger to floating-point"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = uint_to_fp(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = uint_to_fp(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types.replace('float', 'int')", "$types.replace('float', 'int') merge", "$types a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "insn"        : ["vfcvt.x.f.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert floating-point to interger"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = fp_to_int(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = fp_to_int(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types.replace('float', 'uint')", "$types.replace('float', 'uint') merge", "$types a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "insn"        : ["vfcvt.xu.f.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert floating-point to unsigned interger"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = fp_to_uint(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = fp_to_uint(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "self.double_ctype($types).replace('float', 'int') a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfncvt.f.x.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert double-width interger to floating-point"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = wide_int_to_fp(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = wide_int_to_fp(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "self.double_ctype($types).replace('float', 'uint') a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfncvt.f.xu.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert double-width unsigned interger to floating-point"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = wide_uint_to_fp(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = wide_uint_to_fp(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "self.double_ctype($types).replace('int', 'float') a", "$types.replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "int(8|16|32)xm(1|2|4)",
      "insn"        : ["vfncvt.x.f.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert double-width floating-point to interger"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = wide_fp_to_int(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = wide_fp_to_int(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "self.double_ctype($types).replace('uint', 'float') a", "$types.replace('uint', 'e') mask", "unsigned int gvl"],
      "types"       : "uint(8|16|32)xm(1|2|4)",
      "insn"        : ["vfncvt.xu.f.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert double-width floating-point to unsigned interger"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = wide_fp_to_uint(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = wide_fp_to_uint(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types).replace('int', 'float')", "self.double_ctype($types).replace('int', 'float') merge", "$types a", "$types.replace('int', 'e') mask", "unsigned int gvl"],
      "types"       : "int(8|16|32)xm(1|2|4)",
      "insn"        : ["vfwcvt.f.x.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert interger to double-width floating-point"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = int_to_wide_fp(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = int_to_wide_fp(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types).replace('uint', 'float')", "self.double_ctype($types).replace('uint', 'float') merge", "$types a", "$types.replace('uint', 'e') mask", "unsigned int gvl"],
      "types"       : "uint(8|16|32)xm(1|2|4)",
      "insn"        : ["vfwcvt.f.xu.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert unsigned interger to double-width floating-point"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = uint_to_wide_fp(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = uint_to_wide_fp(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types).replace('float', 'int')", "self.double_ctype($types).replace('float', 'int') merge", "$types a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfwcvt.x.f.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert floating-point to double-width integer"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = fp_to_wide_int(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = fp_to_wide_int(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types).replace('float', 'uint')", "self.double_ctype($types).replace('float', 'uint') merge", "$types a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfwcvt.xu.f.v"],
      "class"       : "Conversions between integer and floating-point vector",
      "idoc"        : ["Convert floating-point to double-width unsigned integer"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = fp_to_wide_uint(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = fp_to_wide_uint(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "self.double_ctype($types) a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfncvt.f.f.v"],
      "class"       : "Conversions between floating-point vectors",
      "idoc"        : ["Convert double-width floating-point to current-width"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = wide_fp_to_fp(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = wide_fp_to_fp(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "$types a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfwcvt.f.f.v"],
      "class"       : "Conversions between floating-point vectors",
      "idoc"        : ["Convert current-width floating-point to double-width"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[elemnt] = fp_to_wide_fp(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = fp_to_wide_fp(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    # Vector Floating-Point Compare Instructions
    # ==========================================

    { "name"        : "$insn_mask",
      "prototype"   : ["$types.replace('float', 'e')", "$types.replace('float', 'e') merge", "$types a", "$types b", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "itype"       : ["$types", "$types.replace('float', 'e')"],
      "insn"        : ["vmfeq.vv", "vmfne.vv", "vmflt.vv", "vmfle.vv", "vmfgt.vv", "vmfge.vv", "vmford.vv"],
      "expandvf"    : "b",
      "class"       : "Floating-point relational operations",
      "idoc"        : ["Compare elementwise float @vv for equality@==",
                       "Compare elementwise float @vv for inequality@!=",
                       "Compare elementwise float @vv for lower-than@<",
                       "Compare elementwise float @vv for lower-or-equal@=<",
                       "Compare elementwise float @vv for greater-than@>",
                       "Compare elementwise float @vv for greater-or-equal@>=",
                       "Compute elementwise if @vv are ordered floating-point values"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = (a[element] $idoc b[element]) ? 1 : 0\n"
                      "reuslt[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element] then\n"
                      "    result[element] = (a[element] $idoc b[element]) ? 1 : 0\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
      "operation@vmford.vv" : "for element = 0 to gvl - 1\n"
                              "  result[element] = !is_nan(a[element]) & !is_nan(b[element])\n"
                              "result[gvl : VLMAX] = 0",
      "moperation@vmford.vv" : "for element = 0 to gvl - 1\n"
                               "  if mask[element] then\n"
                               "    result[element] = !is_nan(a[element]) & !is_nan(b[element])\n"
                               "  else\n"
                               "    result[element] = merge[element]\n"
                               "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "self.get_element_ctype($types) a", "unsigned int gvl"],
      "types"       : "float(32|64|16)xm+",
      "insn"        : ["vfmv.v.f"],
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Create a vector that all the elements the same as the given floating-point"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = a\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn",
      "prototype"   : ["$types", "self.get_element_ctype($types) a", "unsigned int gvl"],
      "types"       : "float(32|64|16)xm+",
      "insn"        : ["vfmv.s.f"],
      "class"       : "Vector elements manipulation",
      "idoc"        : ["move a floating-point to the lowest element of the vector"],
      "operation"   : "result[0] = a",
    },

    { "name"        : "$insn",
      "prototype"   : ["self.get_element_ctype($types)", "$types a", "unsigned int gvl"],
      "types"       : "float(32|64|16)xm+",
      "itype"       : "$types",
      "insn"        : ["vfmv.f.s"],
      "class"       : "Vector elements manipulation",
      "idoc"        : ["move the lowest element of a vector to the given floating-point"],
      "operation"   : "result = a[0]",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types a", "self.get_element_ctype($types) b", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(32|64|16)xm+",
      "mask"        : True,
      "insn"        : ["vfmerge.vfm"],
      "class"       : "Vector elements manipulation",
      "idoc"        : ["Merge two floating-point vectors using a mask vector"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = mask[element] ? b : a[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "insn"        : ["vfsqrt.v"],
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Compute the square root"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = sqrt(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[element] = sqrt(a[element])\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types.replace('float', 'uint')", "$types.replace('float', 'uint') merge", "$types a", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "itype"       : "$types",
      "insn"        : ["vfclass.v"],
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Classify every floating-point element as the saclar classify instruction do"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = fclassify(a[element])\n"
                      "result[gvl : VLMAX] = 0",
      "moperation" : "for element = 0 to gvl - 1\n"
                     "  if mask[element]\n"
                     "    result[element] = fclassify(a[element])\n"
                     "  else\n"
                     "    result[element] = merge[element]\n"
                     "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "insn"        : ["vfadd.vv", "vfsub.vv", "vfmul.vv", "vfdiv.vv", "vfmax.vv", "vfmin.vv", "vfsgnj.vv", "vfsgnjn.vv", "vfsgnjx.vv", "vfdot.vv"],
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Elementwise vector-vector floating-point addition@a[element] + b[element]",
                       "Elementwise vector-vector floating-point subtraction@a[element] - b[element]",
                       "Elementwise vector-vector floating-point multiplication@a[element] * b[element]",
                       "Elementwise vector-vector floating-point division@a[element] / b[element]",
                       "Elementwise vector-vector floating-point maxmum@max(a[element], b[element])",
                       "Elementwise vector-vector floating-point minimum@min(a[element], b[element])",
                       "Elementwise vector-vector floating-point sign copy@fsignj(a[element], b[element])",
                       "Elementwise vector-vector floating-point inverted sign copy@fsignjn(a[element], b[element])",
                       "Elementwise vector-vector floating-point XOR sign@fsignx(a[element], b[element])",
                       "Elementwise vector-vector floating-point dot-product@dot-product(a[element], b[element])"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = $idoc\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[element] = $idoc\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
      "coperation"   : ["return a+b;", "return a-b;", "return a*b;", "return a/b;"],
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "self.get_element_ctype($types) b", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(32|64|16)xm+",
      "insn"        : ["vfadd.vf", "vfsub.vf", "vfrsub.vf", "vfmul.vf", "vfdiv.vf", "vfrdiv.vf", "vfmax.vf", "vfmin.vf", "vfsgnj.vf", "vfsgnjn.vf", "vfsgnjx.vf"],
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Elementwise vector-scalar floating-point addition@a[element] + b",
                       "Elementwise vector-scalar floating-point subtraction@a[element] - b",
                       "Elementwise vector-scalar floating-point reverse subtraction@b - a[element]",
                       "Elementwise vector-scalar floating-point multiplication@a[element] * b",
                       "Elementwise vector-scalar floating-point division@a[element] / b",
                       "Elementwise vector-scalar floating-point reverse division@b / a[element]",
                       "Elementwise vector-scalar floating-point maxmum@max(a[element], b)",
                       "Elementwise vector-scalar floating-point minimum@min(a[element], b)",
                       "Elementwise vector-scalar floating-point sign copy@fsignj(a[element], b)",
                       "Elementwise vector-scalar floating-point inverted sign copy@fsignjn(a[element], b)",
                       "Elementwise vector-scalar floating-point XOR sign@fsignx(a[element], b)"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = $idoc\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[element] = $idoc\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "$types a", "$types b", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfwadd.vv", "vfwsub.vv", "vfwmul.vv"],
      "expandvf"    : "b",
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Floating-point @vv widening additon@wide_fp(a[element]) + wide_fp(b[element])",
                       "Floating-point @vv widening subtraction@wide_fp(a[element]) - wide_fp(b[element])",
                       "Floating-point @vv widening multiplication@wide_fp(a[element]) * wide_fp(b[element])"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = $idoc\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[element] = $idoc\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "self.double_ctype($types) a", "$types b", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfwadd.wv", "vfwsub.wv"],
      "expandvf"    : "b",
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Floating-point @vv widening additon(second operand)@a[element] + wide_fp(b[element])",
                       "Floating-point @vv widening subtraction(second operand)@a[element] - wide_fp(b[element])"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = $idoc\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[element] = $idoc\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "$types a", "$types b", "$types c", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm(1|2|4|8)",
      "insn"        : ["vfmacc.vv", "vfnmacc.vv", "vfmsac.vv", "vfnmsac.vv", "vfmadd.vv", "vfnmadd.vv", "vfmsub.vv", "vfnmsub.vv"],
      "expandvf"    : "b",
      "expandm"     : expand_insn_mask_max_args,
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Floating-point @vv multiply and add(overwrite addend)@b[element] * c[element] + a[element]",
                       "Floating-point @vv negate multiply and add(overwrite addend)@-(b[element] * c[element]) - a[element]",
                       "Floating-point @vv multiply and sub(overwrite subtrahend)@b[element] * c[element] - a[element]",
                       "Floating-point @vv negate multiply and sub(overwrite subtrahend)@-(b[element] * c[element]) + a[element]",
                       "Floating-point @vv multiply and add(overwrite multiplicand)@a[element] * b[element] + c[element]",
                       "Floating-point @vv negate multiply and add(overwrite multiplicand)@-(a[element] * b[element]) - c[element]",
                       "Floating-point @vv multiply and sub(overwrite multiplicand)@a[element] * b[element] - c[element]",
                       "Floating-point @vv negate multiply and sub(overwrite multiplicand)@-(a[element] * b[element]) + c[element]"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = $idoc\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[element] = $idoc\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "self.double_ctype($types) merge", "self.double_ctype($types) a", "$types b", "$types c", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfwmacc.vv", "vfwnmacc.vv", "vfwmsac.vv", "vfwnmsac.vv"],
      "expandvf"    : "b",
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Floating-point @vv widening multiply and add@wide_fp(b[element]) * wide_fp(c[element]) + a[element]",
                       "Floating-point @vv widening negate multiply and add@-(wide_fp(b[element]) * wide_fp(c[element])) - a[element]",
                       "Floating-point @vv widening multiply and sub@wide_fp(b[element]) * wide_fp(c[element]) - a[element]",
                       "Floating-point @vv widening negate multiply and sub@-(wide_fp(b[element]) * wide_fp(c[element])) + a[element]"],
      "operation"   : "for element = 0 to gvl - 1\n"
                      "  result[element] = $idoc\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[element] = $idoc\n"
                      "  else\n"
                      "    result[element] = merge[element]\n"
                      "result[gvl : VLMAX] = 0",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types a", "$types b", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float[0-9]*xm+",
      "insn"        : ["vfredosum.vs", "vfredsum.vs", "vfredmax.vs", "vfredmin.vs"],
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Floating-point odered sum of vector@result[0] + a[element]",
                       "Floating-point sum of vector@result[0] + a[element]",
                       "Floating-point maxmum of vector@max(result[0], a[element])",
                       "Floating-point minmum of vector@min(result[0], a[element])"],
      "operation"   : "result[0] = b[0]\n"
                      "for element = 0 to gvl - 1\n"
                      "  result[0] = $idoc",
      "moperation"  : "result[0] = b[0]\n"
                      "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[0] = $idoc",
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["self.double_ctype($types)", "$types a", "self.double_ctype($types) b", "$types.replace('float', 'e') mask", "unsigned int gvl"],
      "types"       : "float(16|32)xm(1|2|4)",
      "insn"        : ["vfwredosum.vs", "vfwredsum.vs"],
      "class"       : "Floating-point arithmetic operations",
      "idoc"        : ["Floating-point widening odered sum of vector",
                       "Floating-point widening sum of vector"],
      "operation"   : "result[0] = b[0]\n"
                      "for element = 0 to gvl - 1\n"
                      "  result[0] = result[0] + wide_fp(a[element])",
      "moperation"  : "result[0] = b[0]\n"
                      "for element = 0 to gvl - 1\n"
                      "  if mask[element]\n"
                      "    result[0] = result[0] + wide_fp(a[element])",
    },

    # Vector Unit-Stride Segment Loads and Stores
    # ===========================================

    # vlseg<nf>{b,h,w}.v vd, (rs1), vm
    # vlseg<nf>{b,h,w}u.v vd, (rs1), vm

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "re.sub('x[0-9]+','',re.sub('u?int','e',$types)) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*x@xm+",
      "insn"        : ["vlseg@b.v", "vlseg@h.v", "vlseg@w.v"],
      "insnu"       : ["vlseg@bu.v", "vlseg@hu.v", "vlseg@wu.v"],
      "expand"      : expand_insn_segmem,
      "expandi"     : expand_insn_mem_types,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Load @ contiguous 8b <$insnu>signed fields in memory to consecutively numbered vector registers",
                       "Load @ contiguous 16b <$insnu>signed fields in memory to consecutively numbered vector registers",
                       "Load @ contiguous 32b <$insnu>signed fields in memory to consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  result[segment] = load_segment(address)\n"
                      "  address = address + sizeof(segment)\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  if mask[segment] then\n"
                      "    result[segment] = load_segment(address)\n"
                      "    address = address + sizeof(segment)\n"
                      "  else\n"
                      "    result[segment] = merge[segment]\n"
                      "result[gvl : VLMAX] = 0",
    },

    # vlseg<nf>e.v vd, (rs1), vm

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "re.sub('x[0-9]+','',re.sub('(u?int|float)','e',$types)) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*x@xm+",
      "insn"        : ["vlseg@e.v"],
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Load @ contiguous element fields in memory to consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  result[segment] = load_segment(address)\n"
                      "  address = address + sizeof(segment)\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  if mask[segment] then\n"
                      "    result[segment] = load_segment(address)\n"
                      "    address = address + sizeof(segment)\n"
                      "  else\n"
                      "    result[segment] = merge[segment]\n"
                      "result[gvl : VLMAX] = 0",
      "attribute"   : {"fake_unsigned": ""}
    },

    # vsseg<nf>{b,h,w,e}.v vs3, (rs1), vm

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "$types a", "re.sub('x[0-9]+','',re.sub('u?int','e',$types)) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*x@xm+",
      "insn"        : ["vsseg@b.v", "vsseg@h.v", "vsseg@w.v"],
      "return"      : False,
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Store @ contiguous 8b fields in memory from consecutively numbered vector registers",
                       "Store @ contiguous 16b fields in memory from consecutively numbered vector registers",
                       "Store @ contiguous 32b fields in memory from consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + sizeof(segment)",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "if mask[segment] then\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + sizeof(segment)",
      "attribute"   : {"fake_unsigned": ""}
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "$types a", "re.sub('x[0-9]+','',re.sub('(u?int|float)','e',$types)) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*x@xm+",
      "insn"        : ["vsseg@e.v"],
      "return"      : False,
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Store @ contiguous element fields in memory from consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + sizeof(segment)",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "if mask[segment] then\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + sizeof(segment)",
      "attribute"   : {"fake_unsigned": ""}
    },

    # Vector Strided Segment Loads and Stores
    # =======================================

    # vlsseg<nf>{b,h,w}.v vd, (rs1), rs2, vm
    # vlsseg<nf>{b,h,w}u.v vd, (rs1), rs2, vm

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "long stride", "re.sub('x[0-9]+','',re.sub('u?int','e',$types)) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*x@xm+",
      "insn"        : ["vlsseg@b.v", "vlsseg@h.v", "vlsseg@w.v"],
      "insnu"       : ["vlsseg@bu.v", "vlsseg@hu.v", "vlsseg@wu.v"],
      "expand"      : expand_insn_segmem,
      "expandi"     : expand_insn_mem_types,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Load @ contiguous 8b <$insnu>signed fields in memory(strided) to consecutively numbered vector registers",
                       "Load @ contiguous 16b <$insnu>signed fields in memory(strided) to consecutively numbered vector registers",
                       "Load @ contiguous 32b <$insnu>signed fields in memory(strided) to consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  result[segment] = load_segment(address)\n"
                      "  address = address + stride\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  if mask[segment] then\n"
                      "    result[segment] = load_segment(address)\n"
                      "    address = address + stride\n"
                      "  else\n"
                      "    result[segment] = merge[segment]\n"
                      "result[gvl : VLMAX] = 0",
    },

    # vlsseg<nf>e.v vd, (rs1), rs2, vm

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "long stride", "re.sub('x[0-9]+','',re.sub('(u?int|float)','e',$types)) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*x@xm+",
      "insn"        : ["vlsseg@e.v"],
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Load @ contiguous element fields in memory(strided) to consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  result[segment] = load_segment(address)\n"
                      "  address = address + stride\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  if mask[segment] then\n"
                      "    result[segment] = load_segment(address)\n"
                      "    address = address + stride\n"
                      "  else\n"
                      "    result[segment] = merge[segment]\n"
                      "result[gvl : VLMAX] = 0",
      "attribute"   : {"fake_unsigned": ""}
    },

    # vssseg<nf>{b,h,w,e}.v vs3, (rs1), rs2, vm

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "long stride", "$types a", "re.sub('x[0-9]+','',re.sub('u?int','e',$types)) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*x@xm+",
      "insn"        : ["vssseg@b.v", "vssseg@h.v", "vssseg@w.v"],
      "return"      : False,
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Store @ contiguous 8b fields in memory(strided) from consecutively numbered vector registers",
                       "Store @ contiguous 16b fields in memory(strided) from consecutively numbered vector registers",
                       "Store @ contiguous 32b fields in memory(strided) from consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + stride",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "if mask[segment] then\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + stride",
      "attribute"   : {"fake_unsigned": ""}
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "long stride", "$types a", "re.sub('x[0-9]+','',re.sub('(u?int|float)','e',$types)) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*x@xm+",
      "insn"        : ["vssseg@e.v"],
      "return"      : False,
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Store @ contiguous element fields in memory(strided) from consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + stride",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "if mask[segment] then\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + stride",
      "attribute"   : {"fake_unsigned": ""}
    },

    # Vector Indexed Segment Loads and Stores
    # =======================================

    # vlxseg<nf>{b,h,w}.v vd, (rs1), vs2, vm
    # vlxseg<nf>{b,h,w}u.v vd, (rs1), vs2, vm

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "re.sub('x[0-9]+','',$types) index", "re.sub('x[0-9]+','',re.sub('u?int','e',$types)) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*x@xm+",
      "ctype"       : "$types",
      "insn"        : ["vlxseg@b.v", "vlxseg@h.v", "vlxseg@w.v"],
      "insnu"       : ["vlxseg@bu.v", "vlxseg@hu.v", "vlxseg@wu.v"],
      "expand"      : expand_insn_segmem,
      "expandi"     : expand_insn_mem_types,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Load @ contiguous 8b <$insnu>signed fields in memory(indexed) to consecutively numbered vector registers",
                       "Load @ contiguous 16b <$insnu>signed fields in memory(indexed) to consecutively numbered vector registers",
                       "Load @ contiguous 32b <$insnu>signed fields in memory(indexed) to consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  result[segment] = load_segment(address)\n"
                      "  address = address + sizeof(segment) + index[segment]\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  if mask[segment] then\n"
                      "    result[segment] = load_segment(address)\n"
                      "    address = address + sizeof(segment) + index[segment]\n"
                      "  else\n"
                      "    result[segment] = merge[segment]\n"
                      "result[gvl : VLMAX] = 0",
    },

    # vlxseg<nf>e.v vd, (rs1), vs2, vm

    { "name"        : "$insn_mask",
      "prototype"   : ["$types", "$types merge", "const self.get_element_ctype($types) *address", "re.sub('x[0-9]+','',$types).replace('float','int') index", "re.sub('x[0-9]+','',re.sub('(u?int|float)','e',$types)) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*x@xm+",
      "ctype"       : "$types",
      "insn"        : ["vlxseg@e.v"],
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Load @ contiguous element fields in memory(indexed) to consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  result[segment] = load_segment(address)\n"
                      "  address = address + sizeof(segment) + index[segment]\n"
                      "result[gvl : VLMAX] = 0",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  if mask[segment] then\n"
                      "    result[segment] = load_segment(address)\n"
                      "    address = address + sizeof(segment) + index[segment]\n"
                      "  else\n"
                      "    result[segment] = merge[segment]\n"
                      "result[gvl : VLMAX] = 0",
      "attribute"   : {"fake_unsigned": ""}
    },

    # vsxseg<nf>{b,h,w,e}.v vs3, (rs1), vs2, vm

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "re.sub('x[0-9]+','',$types) index", "$types a", "re.sub('x[0-9]+','',re.sub('u?int','e',$types)) mask", "unsigned int gvl"],
      "types"       : "u?int[0-9]*x@xm+",
      "ctype"       : "$types",
      "itype"       : "$types",
      "insn"        : ["vsxseg@b.v", "vsxseg@h.v", "vsxseg@w.v"],
      "return"      : False,
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Store @ contiguous 8b fields in memory(indexed) from consecutively numbered vector registers",
                       "Store @ contiguous 16b fields in memory(indexed) from consecutively numbered vector registers",
                       "Store @ contiguous 32b fields in memory(indexed) from consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + sizeof(segment) + index[segment]",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "if mask[segment] then\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + sizeof(segment) + index[segment]",
      "attribute"   : {"fake_unsigned": ""}
    },

    { "name"        : "$insn_mask",
      "prototype"   : ["void", "self.get_element_ctype($types) *address", "re.sub('x[0-9]+','',$types).replace('float','int') index", "$types a", "re.sub('x[0-9]+','',re.sub('(u?int|float)','e',$types)) mask", "unsigned int gvl"],
      "types"       : "(u?int|float)[0-9]*x@xm+",
      "ctype"       : "$types",
      "itype"       : "$types",
      "insn"        : ["vsxseg@e.v"],
      "return"      : False,
      "expand"      : expand_insn_segmem,
      "class"       : "Memory accesses(segment)",
      "idoc"        : ["Store @ contiguous element fields in memory(indexed) from consecutively numbered vector registers",],
      "operation"   : "for segment(@ fields) = 0 to gvl - 1\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + sizeof(segment) + index[segment]",
      "moperation"  : "for segment(@ fields) = 0 to gvl - 1\n"
                      "if mask[segment] then\n"
                      "  store_segment(address, a[segment])\n"
                      "  address = address + sizeof(segment) + index[segment]",
      "attribute"   : {"fake_unsigned": ""}
    },
]


build_builtins_head = '''
#ifndef __GCC_RISCV_VECTOR_H__
#define __GCC_RISCV_VECTOR_H__

#ifndef __riscv_vector
#error "vector require -march the 'v' extension"
#endif

typedef enum {
    RVV_E8 = 0,
    RVV_E16,
    RVV_E32,
    RVV_E64,
} RISCV_VSEW_T;

typedef enum {
    RVV_M1 = 0,
    RVV_M2,
    RVV_M4,
    RVV_M8,
} RISCV_VLMUL_T;

typedef __fp16 float16_t;

typedef float  float32_t;
typedef double float64_t;
'''

build_builtins_tail = '''
#endif
'''

build_doc_intro = '''
Introduction
============

Vector types
------------

An implementation of the RISC-V V-extension features 32 vector registers of length VLEN
bits. Each vector register holds a number of elements. The wider element, in bits, that an
implementation supports is called ELEN.

A vector, thus, can hold VLEN/ELEN elements of the widest element implemented. This
also means that the same vector can hold twice that number of the element is half the
size. This is, a vector of floats will always hold twice the number of elements that a vector
of doubles can hold.

Vector registers in the V-extension can be grouped. Grouping can be 1 (no grouping
actually), 2, 4 or 8. Grouping means larger vectors but in a smaller number (e.g. there are
only 16 registers with grouping 2). Grouping is part of the state of the extension and it is
called LMUL (length multiplier). A LMUL of 1 means no grouping.

The following types are available to operate the vectors under different
LMUL configurations.

    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | Vector of | LMUL=1                   | LMUL=2                   | LMUL=4                   | LMUL=8                   |
    +===========+==========================+==========================+==========================+==========================+
    | double    | .. c:type:: float64xm1_t | .. c:type:: float64xm2_t | .. c:type:: float64xm4_t | .. c:type:: float64xm8_t |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | float     | .. c:type:: float32xm1_t | .. c:type:: float32xm2_t | .. c:type:: float32xm4_t | .. c:type:: float32xm8_t |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | float16   | .. c:type:: float16xm1_t | .. c:type:: float16xm2_t | .. c:type:: float16xm4_t | .. c:type:: float16xm8_t |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | int64     | .. c:type:: int64xm1_t   | .. c:type:: int64xm2_t   | .. c:type:: int64xm4_t   | .. c:type:: int64xm8_t   |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | int32     | .. c:type:: int32xm1_t   | .. c:type:: int32xm2_t   | .. c:type:: int32xm4_t   | .. c:type:: int32xm8_t   |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | int16     | .. c:type:: int16xm1_t   | .. c:type:: int16xm2_t   | .. c:type:: int16xm4_t   | .. c:type:: int16xm8_t   |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | int8      | .. c:type:: int8xm1_t    | .. c:type:: int8xm2_t    | .. c:type:: int8xm4_t    | .. c:type:: int8xm8_t    |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | uint64    | .. c:type:: uint64xm1_t  | .. c:type:: uint64xm2_t  | .. c:type:: uint64xm4_t  | .. c:type:: uint64xm8_t  |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | uint32    | .. c:type:: uint32xm1_t  | .. c:type:: uint32xm2_t  | .. c:type:: uint32xm4_t  | .. c:type:: uint32xm8_t  |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | uint16    | .. c:type:: uint16xm1_t  | .. c:type:: uint16xm2_t  | .. c:type:: uint16xm4_t  | .. c:type:: uint16xm8_t  |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+
    | uint8     | .. c:type:: uint8xm1_t   | .. c:type:: uint8xm2_t   | .. c:type:: uint8xm4_t   | .. c:type:: uint8xm8_t   |
    +-----------+--------------------------+--------------------------+--------------------------+--------------------------+

The syntax of vector types is <element type>x<lmul>_t.

Mask types
----------

    +--------------+----------------------+----------------------+----------------------+----------------------+
    | Element bits | LMUL=1               | LMUL=2               | LMUL=4               | LMUL=8               |
    +==============+======================+======================+======================+======================+
    | 64           | .. c:type:: e64xm1_t | .. c:type:: e64xm2_t | .. c:type:: e64xm4_t | .. c:type:: e64xm8_t |
    +--------------+----------------------+----------------------+----------------------+----------------------+
    | 32           | .. c:type:: e32xm1_t | .. c:type:: e32xm2_t | .. c:type:: e32xm4_t | .. c:type:: e32xm8_t |
    +--------------+----------------------+----------------------+----------------------+----------------------+
    | 16           | .. c:type:: e16xm1_t | .. c:type:: e16xm2_t | .. c:type:: e16xm4_t | .. c:type:: e16xm8_t |
    +--------------+----------------------+----------------------+----------------------+----------------------+
    | 8            | .. c:type:: e8xm1_t  | .. c:type:: e8xm2_t  | .. c:type:: e8xm4_t  | .. c:type:: e8xm8_t  |
    +--------------+----------------------+----------------------+----------------------+----------------------+

The syntax of mask types is <element bits>x<lmul>_t.
Mask types are unrelated to LMUL in that they always use a single vector register.

parameter constraint
--------------------

Immediate
^^^^^^^^^

In vector instruction, immediate is encoded in 5 bits as signed by default
except comment of the specific instruction.

Memory address
^^^^^^^^^^^^^^

If the elements accessed by a vector memory instruction are not naturally aligned
to the memory element size, an address misaligned exception is raised on that element.

Calling Convention
------------------

The RISC-V calling convention passes arguments in registers when possible.
Up to sixteen vector registers, v8–v23 are used for this purpose.

.. table:: vector ABI

    +----------+----------+----------------------------------+--------+
    | Register | ABI Name | Description                      | Saver  |
    +==========+==========+==================================+========+
    | v0-7     | v0-7     | Temporaries                      | Caller |
    +----------+----------+----------------------------------+--------+
    | v8-15    | v8-15    | Function arguments/return values | Caller |
    +----------+----------+----------------------------------+--------+
    | v16-23   | v16-23   | Function arguments               | Caller |
    +----------+----------+----------------------------------+--------+
    | v24-31   | v24-31   | Saved register                   | Callee |
    +----------+----------+----------------------------------+--------+

.. table:: soft vector ABI

    +----------+----------+----------------------------------+--------+
    | Register | ABI Name | Description                      | Saver  |
    +==========+==========+==================================+========+
    | v0-31    | v0-31    | Temporaries                      | Caller |
    +----------+----------+----------------------------------+--------+

Supported Spec
--------------

  RISC-V "V" Vector Extension v0.7.1

Supported CPUs
--------------

    +----------+----------+----------------------------------+--------+
    | CPU      | ABI      | Arch                             | Spec   |
    +==========+==========+==================================+========+
    | 910v     | vector   | gcvxthead                        | 0.7.1  |
    +----------+----------+----------------------------------+--------+

'''

build_doc_example = '''
Examples
========

The following are provided to help explain the vector ISA.

Vector-vector add
-----------------

.. code-block:: c

    #include <riscv-vector.h>

    void vv_add_int32(int number, int *a, int *b, int *c) {

      int32xm2_t va;

      int32xm2_t vb;

      int32xm2_t vc;

      unsigned int gvl = 0;

      for (int i = 0; i < number;) {

         gvl = vsetvli(number - i, RVV_E32, RVV_M2);

         va = vlev_int32xm2(&a[i], gvl);

         vb = vlev_int32xm2(&b[i], gvl);

         vc = vaddvv_int32xm2(va, vb, gvl);

         vsev_int32xm2(&c[i], vc, gvl);

         i += gvl;
      }
    }

Vector-vector add with inner data type
--------------------------------------

.. code-block:: c

    #include <riscv-vector.h>

    void wvv_add_int8 (int8xm1_t a, int8xm1_t b, unsigned int gvl,
                       int16xm1_t *oa, int16xm1_t *ob) {

      int16xm2_u rv;
      rv.v = vwaddvv_int16xm2_int8xm1 (a, b, gvl);
      *oa = rv.m1[0];
      *ob = rv.m1[1];
    }
'''

build_doc_Appendix_A = '''
Appendix A: fcsr
================

.. table:: fcsr layout

    +----------+----------+----------------------------------------+
    | Bits     | Name     | Description                            |
    +==========+==========+========================================+
    | 10:9     | vxrm     | Fixed-point rounding mode              |
    +----------+----------+----------------------------------------+
    | 8        | vxsat    | Fixed-point accrued saturation flag    |
    +----------+----------+----------------------------------------+
    | 7:5      | frm      | Floating-point rounding mode           |
    +----------+----------+----------------------------------------+
    | 4:0      | fflags   | Floating-point accrued exception flags |
    +----------+----------+----------------------------------------+

Vector Floating Rounding Mode Register frm
------------------------------------------

Floating-point operations use either a static rounding mode encoded in
the instruction, or a dynamic rounding mode held in frm. Rounding modes are
encoded as shown below. A value of 111 in the instruction’s rm field
selects the dynamic rounding mode held in frm. If frm is set to an invalid
value (101–111), any subsequent attempt to execute a floating-point operation
with a dynamic rounding mode will cause an illegal instruction trap.
Some instructions that have the rm field are nevertheless unaffected by
the rounding mode; they should have their rm field set to RNE (000).

.. table:: Rounding mode encoding

    +---------------+----------+-----------------------------------------------------------+
    | Rounding Mode | Mnemonic | Meaning                                                   |
    +===============+==========+===========================================================+
    | 000           | RNE      | Round to Nearest, ties to Even                            |
    +---------------+----------+-----------------------------------------------------------+
    | 001           | RTZ      | Round towards Zero                                        |
    +---------------+----------+-----------------------------------------------------------+
    | 010           | RDN      | Round Down (towards -infinity)                            |
    +---------------+----------+-----------------------------------------------------------+
    | 011           | RUP      | Round Up (towards +infinity)                              |
    +---------------+----------+-----------------------------------------------------------+
    | 100           | RMM      | Round to Nearest, ties to Max Magnitude                   |
    +---------------+----------+-----------------------------------------------------------+
    | 101           |          | Invalid. Reserved for future use.                         |
    +---------------+----------+-----------------------------------------------------------+
    | 110           |          | Invalid. Reserved for future use.                         |
    +---------------+----------+-----------------------------------------------------------+
    | 111           |          | In instruction’s rm field, selects dynamic rounding mode; |
    |               |          | In Rounding Mode register, Invalid.                       |
    +---------------+----------+-----------------------------------------------------------+

Vector Fixed-Point Rounding Mode Register vxrm
----------------------------------------------

The vector fixed-point rounding-mode register holds a two-bit read-write
rounding-mode field. The vector fixed-point rounding-mode is given a
separate CSR address to allow independent access, but is also reflected as a
field in the upper bits of fcsr. Systems without floating-point must add fcsr
when adding the vector extension.

The fixed-point rounding algorithm is specified as follows.
Suppose the pre-rounding result is v, and d bits of that result are to be
rounded off. Then the rounded result is (v >> d) + r, where r depends on the
rounding mode as specified in the following table.

.. table:: vxrm encoding

    +------------+--------------+--------------------------------------------+------------------------------+
    | Bits [1:0] | Abbreviation | Rounding Mode                              | Rounding increment, r        |
    +============+==============+============================================+==============================+
    | 0:0        | rnu          | round-to-nearest-up (add +0.5 LSB)         | v[d-1]                       |
    +------------+--------------+--------------------------------------------+------------------------------+
    | 0:1        | rne          | round-to-nearest-even                      | v[d-1] & (v[d-2:0]!=0 | v[d])|
    +------------+--------------+--------------------------------------------+------------------------------+
    | 1:0        | rdn          | round-down (truncate)                      | 0                            |
    +------------+--------------+--------------------------------------------+------------------------------+
    | 1:1        | rod          | round-to-odd (OR bits into LSB, aka "jam") | !v[d] & v[d-1:0]!=0          |
    +------------+--------------+--------------------------------------------+------------------------------+

The rounding function:

roundoff(v, d) = (v >> d) + r
'''


def build_dir(name):
    if not name:
        return None
    if not os.path.exists(name):
        os.mkdir(name)
    return name


class RvvType:
    __support_element_type = {
        'e8': {'mode': 'QI', 'type': 'mask', 'node_type': 'intQI', 'len': 8, 'ctype': 'unsigned char'},
        'e16': {'mode': 'QI', 'type': 'mask', 'node_type': 'intQI', 'len': 8, 'ctype': 'unsigned char'},
        'e32': {'mode': 'QI', 'type': 'mask', 'node_type': 'intQI', 'len': 8, 'ctype': 'unsigned char'},
        'e64': {'mode': 'QI', 'type': 'mask', 'node_type': 'intQI', 'len': 8, 'ctype': 'unsigned char'},
        'int8': {'mode': 'QI', 'type': 'int', 'node_type': 'intQI', 'len': 8, 'ctype': 'signed char'},
        'int16': {'mode': 'HI', 'type': 'int', 'node_type': 'intHI', 'len': 16, 'ctype': 'short'},
        'int32': {'mode': 'SI', 'type': 'int', 'node_type': 'intSI', 'len': 32, 'ctype': 'int'},
        'int64': {'mode': 'DI', 'type': 'int', 'node_type': 'intDI', 'len': 64, 'ctype': 'long'},
        'uint8': {'mode': 'QI', 'type': 'int', 'node_type': 'intQI', 'len': 8, 'ctype': 'unsigned char'},
        'uint16': {'mode': 'HI', 'type': 'int', 'node_type': 'intHI', 'len': 16, 'ctype': 'unsigned short'},
        'uint32': {'mode': 'SI', 'type': 'int', 'node_type': 'intSI', 'len': 32, 'ctype': 'unsigned int'},
        'uint64': {'mode': 'DI', 'type': 'int', 'node_type': 'intDI', 'len': 64, 'ctype': 'unsigned long'},
        'float16': {'mode': 'HF', 'type': 'float', 'node_type': 'riscv_fp16', 'len': 16, 'ctype': 'float16_t'},
        'float32': {'mode': 'SF', 'type': 'float', 'node_type': 'float', 'len': 32, 'ctype': 'float'},
        'float64': {'mode': 'DF', 'type': 'float', 'node_type': 'double', 'len': 64, 'ctype': 'double'}
    }

    __support_lmul = [
        1, 2, 4, 8
    ]

    __support_vlen = [
        64, 128
    ]

    ctypes = {}
    segment_ctypes = {}
    __all_ctypes = {}

    def __init__(self):
        self.max_lmul = max(self.__support_lmul)
        for lmul in self.__support_lmul:
            for element_type, element_type_info in self.__support_element_type.items():
                ctype = self.gen_ctype(element_type, lmul)
                element_ctype = element_type_info['ctype']
                self.ctypes[ctype] = {
                    'element_type': element_type,
                    'element_type_class': element_type_info['type'],
                    'sew': element_type_info['len'],
                    'element_ctype': element_ctype,
                    'unsigned': element_ctype.startswith('u') or element_ctype.startswith('e'),
                    'eltype_node': element_type_info['node_type'],
                    'lmul': lmul,
                    'mode': {}}
                for vlen in self.__support_vlen:
                    self.ctypes[ctype]['mode'][vlen] = \
                        self.gen_mode(element_type_info, lmul, vlen)
                if not element_type.startswith('e'):
                    for segment_nf in range(2, 9):
                        if segment_nf * lmul > self.max_lmul:
                            continue
                        type_name = self.gen_segment_ctype(element_type, lmul, segment_nf)
                        segment_inner_type = self.gen_ctype(element_type, lmul)
                        element_ctype = element_type_info['ctype']
                        self.segment_ctypes[type_name] = {
                            'element_type': element_type,
                            'element_type_class': element_type_info['type'],
                            'sew': element_type_info['len'],
                            'element_ctype': element_ctype,
                            'unsigned': element_ctype.startswith('u') or element_ctype.startswith('e'),
                            'eltype_node': element_type_info['node_type'],
                            'segment_inner_type': segment_inner_type,
                            'lmul': lmul,
                            'nf': segment_nf,
                            'mode': {}
                        }
                        for vlen in self.__support_vlen:
                            self.segment_ctypes[type_name]['mode'][vlen] = \
                                self.gen_mode(element_type_info, lmul, vlen, segment_nf)

    @property
    def all_ctypes(self):
        if not self.__all_ctypes:
            self.__all_ctypes = dict(self.ctypes, **self.segment_ctypes)
        return self.__all_ctypes

    @staticmethod
    def gen_ctype(element_type, lmul):
        return "{}xm{}_t".format(element_type, lmul)

    @staticmethod
    def gen_segment_ctype(element_type, lmul, nf):
        return "{}x{}xm{}_t".format(element_type, nf, lmul)

    @staticmethod
    def gen_mode(element_type_info, lmul, vlen, nf=1):
        if element_type_info['type'] == 'mask':
            bit_size = vlen
        else:
            bit_size = vlen * lmul
        element_count = bit_size / element_type_info['len']
        if nf > 1:
            name = 'VNx{}x{}{}'.format(nf, element_count, element_type_info['mode'].upper())
            byte_count = (bit_size * nf) / 8
        else:
            name = 'V{}{}'.format(element_count, element_type_info['mode'].upper())
            byte_count = bit_size / 8
        avail_flag = "vector{}{}".format(
            vlen,
            "_fp16" if (element_type_info['type'] == 'float' and element_type_info['len'] == 16)
            else ("_hardfloat" if element_type_info['type'] == 'float' else "")
        )
        ret = {
            'name': name,
            'byte_count': byte_count,
            'avail': avail_flag
        }
        return ret

    @staticmethod
    def split_element_type(element_type):
        match_obj = re.match(r'(\D+)(\d+)', element_type)
        if match_obj is not None:
            ret = {
                "type": match_obj.group(1),
                "len": int(match_obj.group(2))
            }
            return ret
        else:
            return {}

    def convert_scalar_type_to_mode(self, scalar_type):
        for element_type, type_info in self.__support_element_type.items():
            if scalar_type == type_info['ctype']:
                return type_info['mode']
            elif scalar_type.endswith('char') and \
                    (scalar_type.startswith('unsigned') and
                     scalar_type.replace('unsigned', "", 1).strip() == type_info['ctype']):
                return type_info['mode']
            elif not scalar_type.endswith('char') and \
                    (scalar_type.startswith('signed') and
                     scalar_type.replace('signed', "", 1).strip() == type_info['ctype']):
                return type_info['mode']
        else:
            assert False

    def gen_builtins_type_union_code(self):
        rets = []
        pattern = "\ntypedef union {\n\
%s\
    %s v;\n\
} %s_u;\n"
        for type_name, type_info in sorted(self.ctypes.items()):
            if type_name.startswith("e"):
                continue

            lmul = type_info['lmul']
            inner_elems = ""
            for i in range(int(math.log(lmul, 2))):
                inner_lmul = pow(2, i)
                num = lmul / inner_lmul
                inner_ctype = self.gen_ctype(type_info['element_type'], inner_lmul)
                inner_elems += "    {} m{}[{}];\n".format(
                    inner_ctype, inner_lmul, num
                )

            if not inner_elems:
                continue

            union_code = pattern % (inner_elems, type_name, type_name.rstrip("_t"))

            if union_code not in rets:
                rets.append(union_code)
        return rets

    def gen_segement_type_union(self):
        rets = []
        pattern_struct = "\ntypedef union {\n    %s val[%s];\n    %s v;\n} %s_u;\n"
        for type_name, type_info in sorted(self.segment_ctypes.items()):
            struct_code = pattern_struct % (type_info['segment_inner_type'],
                                            type_info['nf'],
                                            type_name,
                                            type_name)
            if struct_code not in rets:
                rets.append(struct_code)
        return rets

    def gen_vector_type_def(self, output="riscv-vector-type.def"):
        with open(output, "w") as fp:
            pattern = "RVV_VECTOR_TYPE_DEF ({}, {}, {}, {}{}, {})\n"
            for type_name, type_info in sorted(self.ctypes.items()):
                for vlen in type_info['mode']:
                    mode = type_info['mode'][vlen]['name'].upper() + 'mode'
                    eltype = type_info['element_type']
                    lmul = type_info['lmul']
                    unsigned = "unsigned_" if type_info['unsigned'] else ""
                    eltype_node = type_info['eltype_node']
                    avail = type_info['mode'][vlen]['avail']
                    vector_type_def = pattern.format(mode, eltype, lmul, unsigned, eltype_node, avail)
                    fp.write(vector_type_def)

    def gen_vector_seg_type_def(self, output="riscv-vector-seg-type.def",
                                seg_mode_file="riscv-seg-modes.def", avlen=0):
        seg_modes = {}
        with open(output, "w") as fp:
            pattern = "RVV_VECTOR_SEG_TYPE_DEF ({}, {}, {}, {}, {}, {}, {}, {})\n"
            for type_name, type_info in sorted(self.segment_ctypes.items()):
                for vlen in type_info['mode']:
                    if not avlen or avlen == vlen:
                        mode = type_info['mode'][vlen]['name'] + 'mode'
                        eltype = type_info['element_type']
                        lmul = type_info['lmul']
                        nf = type_info['nf']
                        avail = type_info['mode'][vlen]['avail']
                        sew = type_info['sew']
                        unsigned = 'true' if type_info['unsigned'] else 'false'
                        vector_seg_type_def = pattern.format(mode, eltype, lmul, nf, avail,
                                                             sew, vlen, unsigned)
                        fp.write(vector_seg_type_def)
                        seg_modes[type_info['mode'][vlen]['name']] = {
                            'len': lmul * nf * vlen / 8,
                            'type': type_info['element_type_class'].upper()
                        }
        with open(seg_mode_file, "w") as fp:
            for mode, modeinfo in seg_modes.items():
                fp.write("INT_MODE ({}, {});\n".format(mode, modeinfo['len']))

    def gen_vector_seg_atype_def(self, output="riscv-builtins-v-a.def", avlen=0):
        with open(output, "w") as fp:
            pattern = "#define RISCV_ATYPE_{} riscv_vector_seg_types[{}_{}].node\n"
            for type_name, type_info in sorted(self.segment_ctypes.items()):
                for vlen in type_info['mode']:
                    if not avlen or avlen == vlen:
                        mode = type_info['mode'][vlen]['name']
                        u = "U" if type_info['unsigned'] else ""
                        atype_def = pattern.format(u + mode, type_name, type_info['mode'][vlen]['avail'])
                        fp.write(atype_def)

    def gen_builtins_types(self):
        rets = []
        pattern = "\n#if __riscv_vector == %d\n\
typedef %s __%s __attribute__ ((vector_size (%d)));\n\
typedef __%s %s;\n\
#endif\n"
        for type_name, type_info in sorted(self.ctypes.items()):
             for vlen in type_info['mode']:
                mode_cname = "{}{}".format(
                    "u" if type_info['unsigned'] else "",
                    type_info['mode'][vlen]['name']
                )
                ctype_code = pattern % (vlen, type_info['element_ctype'],
                                        mode_cname,
                                        type_info['mode'][vlen]['byte_count'],
                                        mode_cname,
                                        type_name)
                rets.append(ctype_code)
        return rets

    def gen_seg_mode_iterators(self, output='riscv-v-seg-iterators.md', avlen=0):
        with open(output, 'w') as fp:
            seg_mode_iterator = {}
            for vlen in self.__support_vlen:
                seg_mode_iterator[vlen] = {}
            end_line = '])\n\n'
            seg_base_mode = {}
            seg_nf = {}
            seg_lmul = {}
            for type_name, type_info in sorted(self.segment_ctypes.items()):
                for vlen in type_info['mode']:
                    if not avlen or avlen == vlen:
                        mode_name = type_info['mode'][vlen]['name']
                        seg_mode_iterator[vlen][mode_name] = ""
                        seg_base_mode[mode_name] = \
                            self.ctypes[type_info['segment_inner_type']]['mode'][vlen]['name']
                        seg_nf[mode_name] = type_info['nf']
                        seg_lmul[mode_name] = type_info['lmul']
            for vlen in self.__support_vlen:
                if not avlen or avlen == vlen:
                    fp.write("(define_mode_iterator VANYSEG{} [".format(vlen))
                    index = 0
                    for key in sorted(seg_mode_iterator[vlen].keys()):
                        if not index % 4:
                            fp.write('\n  {}'.format(key))
                        else:
                            fp.write(' {}'.format(key))
                        index += 1
                    fp.write(end_line)
            fp.write("(define_mode_attr SEG_BASE_MODE [")
            index = 0
            for key, value in sorted(seg_base_mode.items()):
                item = '({} "{}")'.format(key, value.upper())
                if not index % 4:
                    fp.write('\n  {}'.format(item))
                else:
                    fp.write(' {}'.format(item))
                index += 1
            fp.write(end_line)
            fp.write("(define_mode_attr seg_base_mode [")
            index = 0
            for key, value in sorted(seg_base_mode.items()):
                item = '({} "{}")'.format(key, value.lower())
                if not index % 4:
                    fp.write('\n  {}'.format(item))
                else:
                    fp.write(' {}'.format(item))
                index += 1
            fp.write(end_line)
            fp.write("(define_mode_attr seg_nf [")
            index = 0
            for key, value in sorted(seg_nf.items()):
                item = '({} "{}")'.format(key, value)
                if not index % 4:
                    fp.write('\n  {}'.format(item))
                else:
                    fp.write(' {}'.format(item))
                index += 1
            fp.write(end_line)
            fp.write("(define_mode_attr seg_lmul [")
            index = 0
            for key, value in sorted(seg_lmul.items()):
                item = '({} "{}")'.format(key, value)
                if not index % 4:
                    fp.write('\n  {}'.format(item))
                else:
                    fp.write(' {}'.format(item))
                index += 1
            fp.write(end_line)


class RvvBuiltins:
    __rv_prefix = "__builtin_riscv_"

    def __init__(self, describe_table, rvv_types):
        """

        :param describe_table:
        :param rvv_types:
        :type rvv_types RvvType
        """
        self.builtins = []
        self.rvv_types = rvv_types
        for item in describe_table:
            if "class" not in item:
                item["class"] = "Unknow"
            if "insn" not in item:
                item["insn"] = [item["name"]]
            item['classes'] = {}
            item['classes']['ifdef'] = ''
            item['classes']['dg_skip_if'] = '-march=rv*v*'
            item['classes']['testsuite_subdir'] = ''

            expands = [RvvBuiltins.expand_def,
                       RvvBuiltins.expand_vv,
                       RvvBuiltins.expand_mask,
                       self.expand_type,
                       RvvBuiltins.expand_insn]

            def expander(arg_expands, i, arg_item):
                rets = []
                if i < 0:
                    return [arg_item]
                for x in expander(arg_expands, i - 1, arg_item):
                    rets += arg_expands[i](x)
                return rets

            expanded_items = expander(expands, len(expands) - 1, item)

            self.builtins += expanded_items
        self.calculate_arguments()
        self.calculate_mode_related_info()
        self.calculate_classes()
        self.builtins.sort(key=lambda a: a['classes']['ifdef'])

    def calculate_classes(self):
        for describe_item in self.builtins:
            if self.has_vfloat_type(describe_item):
                describe_item['classes']['ifdef'] = '__riscv_flen'
                describe_item['classes']['dg_skip_if'] = '-march=*f*d*v*'
                describe_item['classes']['testsuite_subdir'] = ''
            if "types" in describe_item.keys() and describe_item["types"].startswith("float16"):
                describe_item['classes']['ifdef'] = '__riscv_fp16'
                describe_item['classes']['dg_skip_if'] = '-march=*f*d*v*'
                describe_item['classes']['testsuite_subdir'] = 'fp16'

    def has_vfloat_type(self, describe_item):
        types = [describe_item['ret']['ret_type']]
        types += describe_item['arguments']['arg_types']
        for atype in types:
            if atype in self.rvv_types.all_ctypes and atype.startswith('float'):
                return True
        return False

    def calculate_arguments(self):
        for describe_item in self.builtins:
            describe_item['arguments'] = {}
            describe_item['ret'] = {}
            # Calculate argument type and name, builtin passing arguments
            arg_types = []
            arg_names = []
            builtin_pass_args = []
            builtin_pass_arg_types = []
            is_use_signed = []
            for arg in describe_item['prototype'][1:]:
                arg_splits = arg.split()
                arg_name = arg_splits[-1].replace('*', '')
                arg_type = " ".join(arg_splits[:-1])
                arg_is_use_signed = False
                type_converted = False
                type_index = 0
                if arg_splits[0] == 'const':
                    type_index = 1
                if "insnc" in describe_item and not arg.endswith('gvl'):
                    if not describe_item['insnc'] or ('!' + arg_name) not in describe_item['insnc'].split(','):
                        if arg_splits[type_index].startswith('u'):
                            arg_splits[type_index] = arg_splits[type_index].lstrip('un')
                            type_converted = True
                        arg_is_use_signed = True
                has_p = '*' in arg
                if type_converted or ('*' in arg and 'const' in arg_splits):
                    arg_splits = [a.replace('*', '').strip() for a in arg_splits]
                    if 'const' in arg_splits:
                        arg_splits.remove('const')
                    builtin_pass_arg_type = " ".join(arg_splits[:-1]) + (" *" if has_p else "")
                    builtin_pass_arg = "({}){}".format(builtin_pass_arg_type, arg_name)
                else:
                    builtin_pass_arg_type = " ".join(arg_splits[:-1]) + (" *" if has_p else "")
                    builtin_pass_arg = arg_name
                arg_types.append(arg_type)
                arg_names.append(arg_name)
                builtin_pass_args.append(builtin_pass_arg)
                is_use_signed.append(arg_is_use_signed)
                builtin_pass_arg_types.append(builtin_pass_arg_type)
            describe_item['arguments']['arg_types'] = arg_types
            describe_item['arguments']['arg_names'] = arg_names
            describe_item['arguments']['builtin_pass_args'] = builtin_pass_args
            describe_item['arguments']['is_use_signed'] = is_use_signed
            describe_item['arguments']['builtin_pass_arg_types'] = builtin_pass_arg_types
            # Calculate return type and buitlin return type
            ret = describe_item["prototype"][0]
            describe_item['ret']['ret_type'] = ret
            builtin_pass = ""
            builtin_type = ret
            if "insnc" in describe_item and ret != 'void':
                builtin_pass = "({})".format(ret)
                builtin_type = ret.lstrip('un')
            describe_item['ret']['builtin_pass'] = builtin_pass
            describe_item['ret']['builtin_type'] = builtin_type
            self.gen_function_name(describe_item)
            describe_item['sort'] = describe_item["prototype"][0] + describe_item["function_name"]

    @staticmethod
    def groupby(list_to_group, group_key):
        list_sorted = sorted(list_to_group, key=group_key)
        return groupby(list_sorted, key=group_key)

    def calculate_mode_related_info(self):
        for describe_item in self.builtins:
            if "types" not in describe_item:
                continue
            real_type = self.get_realtype_from_function_name(describe_item)
            type_info = self.rvv_types.all_ctypes[real_type]
            describe_item['mode_related'] = {}
            for vlen in type_info['mode']:
                describe_item['mode_related'][vlen] = {}
                # Calculate icode name
                if "itype" in describe_item:
                    mode_suffix = self.gen_type_mode_suffix(describe_item['itype'],
                                                            vlen)
                else:
                    mode_suffix = type_info['mode'][vlen]['name']
                icode = "{}_{}".format(
                    describe_item['name'],
                    mode_suffix.lower()
                )
                if self.has_attribute(describe_item, "segmem_expand"):
                    icode = re.sub(r'seg\d', 'seg', icode)
                if self.has_attribute(describe_item, "fake_unsigned") and type_info['unsigned']:
                    builtin_fname = icode + '_u'
                else:
                    builtin_fname = icode
                describe_item['mode_related'][vlen]['icode'] = icode
                describe_item['mode_related'][vlen]['builtin_fname'] = builtin_fname
                # Calculate function type
                function_type = self.gen_function_type(describe_item, vlen)
                describe_item['mode_related'][vlen]['function_type'] = function_type

    # If the function_type is not related with vlen, then set to zero
    def gen_function_type(self, describe_item, vlen=0, mode=0):
        """

        :param describe_item:
        :param vlen: Set vlen to 0 when it is vlen independent.
        :param mode: The function type mode,
                    0: Use mode
                    1: Define mode
        :return:
        """
        assert mode == 0 or mode == 1
        use_mode_pattern = "RISCV_%s_FTYPE_%s"
        def_mode_pattern = "DEF_RISCV_FTYPE (%d, (%s, %s))\n"
        ret_mode_def = ""
        args_mode_def = []
        if "ftype" in describe_item:
            ret_mode_def = describe_item['ftype'][0]
            args_mode_def = describe_item['ftype'][1:]
        if not ret_mode_def:
            ret_mode = ""
            ret_builtin_type = describe_item['ret']['builtin_type']
            if ret_builtin_type.startswith('u') or ret_builtin_type.startswith('e'):
                ret_mode = "U"
            ret_mode += self.convert_ctype_to_mode(ret_builtin_type, vlen)
        else:
            ret_mode = ret_mode_def
        args_mode = []
        for index, arg_type in enumerate(describe_item['arguments']['builtin_pass_arg_types']):
            if "ftype" in describe_item and args_mode_def[index]:
                args_mode.append(args_mode_def[index])
            else:
                ptr_str = ""
                if arg_type.endswith('*'):
                    arg_type = arg_type.replace("*", "").strip()
                    ptr_str = "PTR"
                arg_mode = ""
                arg_type = arg_type.replace('const', '').strip()
                if arg_type.startswith('u') or arg_type.startswith('e'):
                    arg_mode = "U"
                arg_mode += self.convert_ctype_to_mode(arg_type, vlen)
                arg_mode += ptr_str
                args_mode.append(arg_mode)
        if mode == 0:
            args_mode_str = "_".join(args_mode)
            function_type = use_mode_pattern % (ret_mode, args_mode_str)
        elif mode == 1:
            args_mode_str = ", ".join(args_mode)
            args_len = len(describe_item['arguments']['builtin_pass_arg_types'])
            function_type = def_mode_pattern % (args_len, ret_mode, args_mode_str)
        return function_type

    def convert_ctype_to_mode(self, ctype, vlen):
        if ctype == 'void':
            return 'VOID'
        if ctype in self.rvv_types.all_ctypes:
            assert vlen != 0
            return self.rvv_types.all_ctypes[ctype]['mode'][vlen]['name']
        else:
            return self.rvv_types.convert_scalar_type_to_mode(ctype)

    def get_element_ctype(self, type_name):
        return self.rvv_types.all_ctypes[type_name]['element_ctype']

    def double_ctype(self, type_name):
        ctype = self.rvv_types.ctypes[type_name]
        element_base = self.rvv_types.split_element_type(ctype['element_type'])
        new_element_type = "{}{}".format(element_base['type'], element_base['len'] * 2)
        new_ctype = self.rvv_types.gen_ctype(new_element_type, ctype['lmul'] * 2)
        return new_ctype

    def gen_function_name(self, describe_item):
        function_name = describe_item['name']
        ret = describe_item['ret']['ret_type']
        args = describe_item['prototype'][1:]
        if "ctype" in describe_item:
            function_name += "_" + self.gen_type_suffix(describe_item["ctype"])
        elif "types" in describe_item:
            types = [ret] + map(lambda m: "".join(m.split()[:-1]), args)
            suffix_types = []
            for t in types:
                if t not in self.rvv_types.all_ctypes.keys():
                    continue
                if t.startswith("e") and function_name.endswith("_mask"):
                    ti = types.index(t)
                    if ti and args[ti - 1].split()[-1].startswith("mask"):
                        continue
                if t in suffix_types:
                    continue
                suffix_types.append(t)
            function_name += "_" + "_".join(map(lambda m: m.rstrip("_t"), suffix_types))
        describe_item["function_name"] = function_name

    @staticmethod
    def expand_def(describe_item):
        if "expand" in describe_item:
            return describe_item["expand"](describe_item)
        return [describe_item]

    @staticmethod
    def expand_vv(describe_item):
        rets = [describe_item]

        vv_expanders = {
            "expandvf": {
                "fix_insn": lambda m: m[::-1].replace("v", "f", 1)[::-1],
                "fix_prototype": lambda m: (m.endswith(" " + arg) and ("self.get_element_ctype(%s) %s" % (m.rstrip(arg), arg))) or m,
                "idoc": "vector-scalar ",
            },
            "expandvx": {
                "fix_insn": lambda m: m[::-1].replace("v", "x", 1)[::-1],
                "fix_prototype": lambda m: (m.endswith(" " + arg) and ("self.get_element_ctype(%s) %s" % (m.rstrip(arg), arg))) or m,
                "idoc": "vector-scalar ",
            },
            "expandvi": {
                "fix_insn": lambda m: re.sub("\\.v.?", ".vi", m),
                "fix_prototype": lambda m: (m.endswith(" " + arg) and
                                            (("$types" in m and
                                              ("const self.get_element_ctype(%s)%s %s" % (m.rstrip(arg), argt, arg)))
                                             or "const " + m)) or m,
                "idoc": "vector-immediate ",
            },
        }

        operand = None
        if "idoc" in describe_item:
            operand = ""
            if "insnu" in describe_item:
                operand = "<$insnu>signed "

        for vv_expander_name, vv_expander in vv_expanders.items():
            if vv_expander_name not in describe_item.keys():
                continue
            new_item = copy.deepcopy(describe_item)

            if "@" in new_item[vv_expander_name]:
                arg, index, imm = tuple(new_item[vv_expander_name].replace("@", ":").split(":"))
                index = int(index)
                new_item[vv_expander_name] = "%s:%s" % (arg, imm)
                new_item["insn"] = [new_item["insn"][index]]
                if "insnu" in new_item.keys():
                    new_item["insnu"] = [new_item["insnu"][index]]
                if "idoc" in new_item.keys():
                    new_item["idoc"] = [new_item["idoc"][index]]

            new_item["insn"] = map(vv_expander["fix_insn"], new_item["insn"])
            if "insnu" in new_item.keys():
                new_item["insnu"] = map(vv_expander["fix_insn"], new_item["insnu"])

            arg = new_item[vv_expander_name].split(":")[0]
            imm = new_item[vv_expander_name].split(":")[-1]
            imm = (imm != arg and imm) or None
            argt = ("signed" in new_item[vv_expander_name] and ".replace('unsigned','signed')") or ""

            new_item["prototype"] = map(vv_expander["fix_prototype"], new_item["prototype"])

            if imm is not None:
                param = map(lambda m: m.split()[-1], new_item["prototype"][1:])
                param[param.index(arg)] = imm
                new_item["param"] = ", ".join(param)

            if operand is not None:
                new_item["idoc"] = map(lambda m: re.sub("@v.? ", operand + vv_expander["idoc"], m), new_item["idoc"])
                new_item["idoc"] = map(lambda m: m.replace("%s[element]" % arg, arg), new_item["idoc"])

            keys = filter(lambda m: m.startswith("operation") or m.startswith("moperation"), new_item.keys())
            for i in keys:
                new_item[i] = new_item[i].replace("%s[element]" % arg, arg)

            rets.append(new_item)

        if operand is not None:
            describe_item["idoc"] = map(lambda m: re.sub("@vv ", operand + "vector-vector ", m), describe_item["idoc"])
            describe_item["idoc"] = map(lambda m: re.sub("@vx ", operand + "vector-scalar ", m), describe_item["idoc"])

        return rets

    @staticmethod
    def expand_mask(describe_item):
        rets = [describe_item]
        if describe_item["name"].endswith("_mask") and "mask" not in describe_item:
            new_item = copy.deepcopy(describe_item)
            new_item["name"] = new_item["name"].replace("_mask", "")
            new_item["prototype"] = filter(lambda m: not m.endswith(" mask"), new_item["prototype"])
            new_item["prototype"] = filter(lambda m: not m.endswith(" merge"), new_item["prototype"])

            if "param" in new_item.keys():
                new_item["param"] = new_item["param"].replace("merge,", "")
                new_item["param"] = re.sub(",[ ]*mask", "", new_item["param"])

            rets.append(new_item)
        if "expandm" in describe_item.keys():
            rets.remove(describe_item)
            rets += describe_item["expandm"](describe_item)
        return rets

    def replace_type_in_prototype(self, prototype, type_value):
        for arg in prototype:
            if "$" not in arg:
                continue
            index = prototype.index(arg)
            if index:
                arg_parts = arg.split()
                arg_name = arg_parts[-1]
                arg_parts.remove(arg_name)
                arg_prefix = ""
                if "$" not in arg_parts[0]:
                    arg_prefix = arg_parts[0]
                    arg_parts.remove(arg_prefix)
                arg_type = "".join(arg_parts)
            # Return value don't have prefix and name.
            else:
                arg_name = ""
                arg_prefix = ""
                arg_type = arg
            arg_type = arg_type.replace("$types", "\'" + type_value + "\'")
            arg_type = eval(arg_type)
            new_arg = arg_type
            if arg_name:
                new_arg += " " + arg_name
                if arg_prefix:
                    new_arg = arg_prefix + " " + new_arg
            prototype[index] = new_arg

    def expand_type(self, describe_item):
        rets = []
        if "types" not in describe_item:
            rets.append(describe_item)
            return rets
        for type_name, type_info in self.rvv_types.all_ctypes.items():
            if not re.match(describe_item["types"], type_name):
                continue
            new_item = copy.deepcopy(describe_item)
            new_item["types"] = type_name
            prototype = new_item["prototype"]
            self.replace_type_in_prototype(prototype, type_name)

            for t in ["itype", "ctype"]:
                if t in new_item:
                    if isinstance(new_item[t], str):
                        type_items = [new_item[t]]
                    else:
                        type_items = new_item[t]
                    assert isinstance(type_items, list)
                    for index, type_item in enumerate(type_items):
                        if "$" not in type_item:
                            continue
                        type_eval = eval(type_item.replace("$types", "\'" + new_item["types"] + "\'"))
                        type_items[index] = type_eval
                    new_item[t] = type_items

            rets.append(new_item)

        return rets

    @staticmethod
    def gen_type_suffix(type_items):
        type_striped = []
        for type_item in type_items:
            type_striped.append(type_item.rstrip("_t"))
        return "_".join(type_striped)

    def gen_type_mode_suffix(self, type_items, vlen):
        modes = []
        for type_item in type_items:
            mode = self.rvv_types.all_ctypes[type_item]['mode'][vlen]['name'].lower()
            modes.append(mode)
        return "_".join(modes)

    @staticmethod
    def expand_coperation(describe_item, index):
        if "coperation" not in describe_item:
            return
        if index >= len(describe_item["coperation"]):
            del describe_item["coperation"]
            return
        describe_item["coperation"] = describe_item["coperation"][index]

    @staticmethod
    def expand_idoc(describe_item, index):

        def expand_idoc_operation(okeys, insn):
            for key in okeys:
                insns = key.split("@")[-1].split(",")
                if insn in insns:
                    return key
            return ""

        def expand_idoc_format(doc, op):
            if doc.find("$idoc") != -1:
                doc = doc.replace("$idoc", op)
            doc = doc.replace("\n", "\n      ")
            doc = "\n  >>> " + doc
            return doc

        if "idoc" not in describe_item.keys():
            return
        idoc = describe_item["idoc"][index].split("@")[0]
        op = describe_item["idoc"][index].split("@")[-1]
        iname = describe_item["insn"][0]

        if "insnu" in describe_item and "types" in describe_item:
            un = describe_item["types"].startswith("u") and "un" or ""
            idoc = idoc.replace("<$insnu>", un)

        describe_item["idoc"] = idoc

        okeys = filter(lambda m: m.startswith("operation@"), describe_item.keys())
        mkeys = filter(lambda m: m.startswith("moperation@"), describe_item.keys())

        okeys = expand_idoc_operation(okeys, iname)
        if okeys:
            describe_item["operation"] = describe_item[okeys]
        mkeys = expand_idoc_operation(mkeys, iname)
        if mkeys:
            describe_item["moperation"] = describe_item[mkeys]

        op = op != idoc and op or iname

        if "operation" in describe_item:
            describe_item["operation"] = expand_idoc_format(describe_item["operation"], op)

        if "moperation" in describe_item:
            describe_item["moperation"] = expand_idoc_format(describe_item["moperation"], op)

    @staticmethod
    def expand_insn(describe_item):
        rets = []
        if not re.match(".*\\$insn", describe_item["name"]):
            RvvBuiltins.expand_idoc(describe_item, 0)
            RvvBuiltins.expand_coperation(describe_item, 0)
            return [describe_item]
        for current_insn in describe_item["insn"]:
            if "expandi" in describe_item:
                if not describe_item["expandi"](describe_item, current_insn):
                    continue
            new_item = copy.deepcopy(describe_item)
            index = new_item["insn"].index(current_insn)
            if "insnu" in new_item:
                if len(new_item["insnu"]) > index and new_item["types"].startswith("u"):
                    current_insn = new_item["insnu"][index]
            new_item["name"] = new_item["name"].replace("$insn", current_insn.replace(".", ""))
            new_item["insn"] = [current_insn]
            RvvBuiltins.expand_idoc(new_item, index)
            RvvBuiltins.expand_coperation(new_item, index)
            rets.append(new_item)
        return rets

    @staticmethod
    def has_attribute(describe_item, attribute):
        return "attribute" in describe_item and attribute in describe_item["attribute"]

    def gen_builtin_decls(self):
        rets = []
        builtins_decl_pattern = '''
__extension__ static __inline __attribute__ ((__always_inline__))
%s {
%s
}
'''

        for iclass, group in self.groupby(self.builtins, lambda a: a['classes']['ifdef']):
            if iclass:
                rets.append("\n#ifdef %s\n" % iclass)

            group = list(group)
            group.sort(key=itemgetter('sort'))
            for describe_item in group:
                prototype = "%s %s (%s)" % (describe_item['ret']['ret_type'],
                                            describe_item['function_name'],
                                            ", ".join(describe_item['prototype'][1:]))
                builtin_pass_args = ", ".join(describe_item['arguments']['builtin_pass_args'])
                if "types" not in describe_item:
                    content = "    return %s%s (%s);" % (self.__rv_prefix,
                                                         describe_item['function_name'],
                                                         builtin_pass_args)
                else:
                    content_pattern = "\n#if __riscv_vector == %d\n\
    return %s%s (%s);\n\
#endif"
                    real_type = self.get_realtype_from_function_name(describe_item)
                    type_info = self.rvv_types.all_ctypes[real_type]
                    content = ""
                    ret = describe_item['ret']['builtin_pass']
                    for vlen in type_info['mode']:
                        builtin_function_name = "{}{}".format(
                            self.__rv_prefix,
                            describe_item['mode_related'][vlen]['builtin_fname']
                        )
                        content += content_pattern % (vlen, ret, builtin_function_name,
                                                      builtin_pass_args)
                rets.append(builtins_decl_pattern % (prototype, content))
            if iclass:
                rets.append("\n#endif\n")
        return rets

    @staticmethod
    def get_realtype_from_function_name(describe_item):
        types = describe_item['function_name'].replace(describe_item["name"], "").strip("_")
        types = map(lambda m: m + "_t", types.split("_"))
        return types[0]

    def gen_builtin_defs(self, scalar_ftype_def_file='riscv-ftypes.def',
                         builtin_defs_file='riscv-builtins-v.def',
                         ftype_defs_file='riscv-ftypes-v.def',
                         special_ftype_def_file='riscv-ftypes-special.def', seg_avlen=0):
        ret_func_defs = {}
        ret_fytpe_defs = {}
        scalar_ftype_defs = {}
        index_set_ftype_defs = {}
        index_get_ftype_defs = {}
        builtins_def_pattern = "\nRISCV_BUILTIN (%s, \"%s\", RISCV_BUILTIN_DIRECT%s, %s, %s),"

        with open(scalar_ftype_def_file) as fp:
            for i in fp.readlines():
                if i and i.startswith("DEF_RISCV_FTYPE"):
                    continue
                scalar_ftype_defs[i] = ""

        for iclass, group in self.groupby(self.builtins, lambda a: a['classes']['ifdef']):
            group = list(group)
            group.sort(key=itemgetter('prototype'))
            for describe_item in group:
                ireturn = "_NO_TARGET" if ("return" in describe_item and not describe_item["return"]) else ""
                if "types" not in describe_item:
                    icode = describe_item['function_name']
                    function_type = self.gen_function_type(describe_item)
                    builtin_def = builtins_def_pattern % (icode, icode, ireturn, function_type, "vector")
                    ret_func_defs[builtin_def] = ""
                    # Calculate funtion type defination
                    function_type_def = self.gen_function_type(describe_item, mode=1)
                    if function_type_def not in scalar_ftype_defs:
                        ret_fytpe_defs[function_type_def] = ""
                    if "INDEX" in function_type:
                        if "set" in icode:
                            index_set_ftype_defs[function_type] = ""
                        elif "get" in icode:
                            index_get_ftype_defs[function_type] = ""
                        else:
                            assert True
                else:
                    real_type = self.get_realtype_from_function_name(describe_item)
                    type_info = self.rvv_types.all_ctypes[real_type]
                    for vlen in type_info['mode']:
                        if 'nf' in type_info and seg_avlen and seg_avlen != vlen:
                            continue
                        icode = describe_item['mode_related'][vlen]['icode']
                        builtin_fname = describe_item['mode_related'][vlen]['builtin_fname']
                        function_type = describe_item['mode_related'][vlen]['function_type']
                        condition = type_info['mode'][vlen]['avail']
                        builtin_def = builtins_def_pattern % (icode, builtin_fname, ireturn,
                                                              function_type, condition)
                        ret_func_defs[builtin_def] = ""
                        # Calculate funtion type defination
                        function_type_def = self.gen_function_type(describe_item, vlen, mode=1)
                        if function_type_def not in scalar_ftype_defs:
                            ret_fytpe_defs[function_type_def] = ""
                        if "INDEX" in function_type:
                            if "set" in icode:
                                index_set_ftype_defs[function_type] = ""
                            elif "get" in icode:
                                index_get_ftype_defs[function_type] = ""
                            else:
                                assert True
        with open(builtin_defs_file, "w") as riscv_builtin_def_fp, \
                open(ftype_defs_file, "w") as riscv_ftype_fp, \
                open(special_ftype_def_file, "w") as riscv_sepcial_ftype_fp:
            for ret_func_def in sorted(ret_func_defs.keys(), key=lambda m: m.split("(")[-1].split(",")[0]):
                riscv_builtin_def_fp.write(ret_func_def)
            for ret_fytpe_def in sorted(ret_fytpe_defs.keys(), key=lambda m: m.split("(")[1]):
                riscv_ftype_fp.write(ret_fytpe_def)
            riscv_sepcial_ftype_fp.write("#ifdef RISCV_INDEX_SET_FTYPE\n")
            for index_set_ftype_def in sorted(index_set_ftype_defs.keys()):
                riscv_sepcial_ftype_fp.write("RISCV_INDEX_SET_FTYPE({})\n".format(index_set_ftype_def))
            riscv_sepcial_ftype_fp.write("#endif\n\n")
            riscv_sepcial_ftype_fp.write("#ifdef RISCV_INDEX_GET_FTYPE\n")
            for index_get_ftype_def in sorted(index_get_ftype_defs.keys()):
                riscv_sepcial_ftype_fp.write("RISCV_INDEX_GET_FTYPE({})\n".format(index_get_ftype_def))
            riscv_sepcial_ftype_fp.write("#endif\n\n")

    def write_testsuite(self, testsuite_dir="./vector/"):
        build_builtins_head_t = '''
/* { dg-do assemble } */
/* { dg-skip-if "test vector insns" { *-*-* } { "*" } { "%s" } } */
/* { dg-options "-O2 --save-temps" } */

#include <riscv-vector.h>
'''
        build_builtins_prototype_t = '''
%s {
%s
}

'''
        build_builtins_tail_t = '''
/* { dg-final { cleanup-saved-temps } } */

'''
        for name, group in self.groupby(self.builtins, itemgetter('name')):
            for subdir, dir_group in self.groupby(group, lambda a: a['classes']['testsuite_subdir']):
                insns = list(dir_group)
                insns.sort(key=itemgetter('sort'))
                full_dir = build_dir(os.path.join(testsuite_dir, subdir))
                with open(os.path.join(full_dir, name + ".c"), "w") as fp:
                    fp.write(build_builtins_head_t % insns[0]['classes']['dg_skip_if'])
                    # Write test functions
                    for intrinsic in insns:
                        test_func_decl = "{} {} ({})".format(
                            intrinsic['ret']['ret_type'],
                            "test_" + intrinsic['function_name'],
                            ", ".join(intrinsic['prototype'][1:])
                        )
                        if 'param' in intrinsic:
                            param = intrinsic['param']
                        else:
                            param = ", ".join(intrinsic['arguments']['arg_names'])
                        test_func_content = "    return {} ({});".format(
                            intrinsic['function_name'],
                            param
                        )
                        test_func = build_builtins_prototype_t % (test_func_decl, test_func_content)
                        fp.write(test_func)
                    # Write scan-assembler
                    for intrinsic in insns:
                        if "optimized" in intrinsic['insn'][0]:
                            continue
                        insn = intrinsic['insn'][0].replace('.', '\\.')
                        if 'types' in intrinsic:
                            assert intrinsic['types'] in self.rvv_types.all_ctypes
                            sew = self.rvv_types.all_ctypes[intrinsic['types']]['sew']
                            lmul = self.rvv_types.all_ctypes[intrinsic['types']]['lmul']
                            pattern = "vsetvli\\t\\[a-z\\]+\\[0-9\\]+,\\[a-z\\]+\\[0-9\\]+,e{},m{}.*{}".format(
                                sew, lmul, insn
                            )
                        else:
                            pattern = insn + "\\t"
                        dg_final = "/* { dg-final { scan-assembler \"%s\" } }*/\n" % pattern
                        fp.write(dg_final)
                    fp.write(build_builtins_tail_t)

    def write_document(self, doc_dir="./"):
        build_doc_config = """
# -*- coding: utf-8 -*-

project = u'Vector Intrinsic Manual'
author = u'CompilerTeam'
release = u'1.2.1'

master_doc = 'index'

latex_elements = {

    'preamble': r'''
\usepackage{draftwatermark}
\SetWatermarkText{T-HEAD}
''',
}

"""
        build_doc_index = '''
riscv vector
============
..  toctree::
    :maxdepth: 3

    %(names)s
'''
        if not os.path.exists(doc_dir):
            os.mkdir(doc_dir)
        os.chdir(doc_dir)
        build_dir("builtins")
        indexes = [
            self.write_document_file("intro.rst", build_doc_intro),
            self.write_document_builtins("builtins"),
            self.write_document_file("example.rst", build_doc_example),
            self.write_document_file("Appendix_A.rst", build_doc_Appendix_A),
        ]
        self.write_document_file("index.rst", build_doc_index % {"names": "\n    ".join(indexes)})
        self.write_document_file("conf.py", build_doc_config)

    @staticmethod
    def write_document_file(filename, content):
        with open(filename, "w") as fp:
            fp.write(content)
        return os.path.splitext(filename)[0]

    def write_document_builtins(self, builtin_dir):
        doc_builtins_index = '''
Reference
=========
..  toctree::

    %(names)s
'''
        doc_builtins_prolog = '''
**%(class)s**
=============

.. highlight:: c

'''
        doc_builtins_prototype_prolog = '''
%(idoc)s
--------

**Instruction:**
%(insn)s

'''
        doc_builtins_prototype = '''
**Prototypes:**
%(prototype)s

**Operation:**
%(operation)s

'''
        doc_builtins_prototype_mask = '''
**Masked prototypes:**
%(prototype)s

**Masked operation:**
%(operation)s

'''
        prev_dir = os.getcwd()
        os.chdir(builtin_dir)
        builtins_group = self.groupby(self.builtins, itemgetter('class'))

        indexes = []
        for class_name, intrinsics in builtins_group:
            class_name = class_name.split("@")[-1]
            class_index_name = class_name.replace(" ", "-")
            indexes.append(class_index_name)
            with open(class_index_name + ".rst", "w") as fp:
                fp.write(doc_builtins_prolog % {"class": class_name})
                insn_group = self.groupby(intrinsics, itemgetter('insn'))

                for name, insns in insn_group:
                    insns = sorted(list(insns), key=itemgetter('function_name'))
                    insn = insns[0]

                    if 'idoc' not in insn:
                        continue

                    fp.write(doc_builtins_prototype_prolog % insn)

                    prototype = {
                        "i": {"pattern": doc_builtins_prototype,
                              "prototype": "",
                              "operation": "operation" in insn and insn["operation"]},
                        "m": {"pattern": doc_builtins_prototype_mask,
                              "prototype": "",
                              "operation": "moperation" in insn and insn["moperation"]
                                           or insn["operation"]},
                    }
                    for sub_insn in insns:
                        w = "\n* .. c:function:: %s %s (%s)" % (sub_insn['ret']['ret_type'],
                                                                sub_insn['function_name'],
                                                                ", ".join(sub_insn['prototype'][1:]))
                        if sub_insn["name"].endswith("_mask"):
                            prototype["m"]["prototype"] += w
                        else:
                            prototype["i"]["prototype"] += w
                    for k, v in prototype.items():
                        if v["prototype"]:
                            fp.write(v["pattern"] % v)
        index_content = doc_builtins_index % {"names": "\n    ".join(indexes)}
        index_for_prev = os.path.join(builtin_dir,
                                      self.write_document_file('index.rst', index_content))
        os.chdir(prev_dir)
        return index_for_prev


def main():
    os.chdir(scritp_dirname)
    rvv_type = RvvType()
    rvv_builtins = RvvBuiltins(builtins, rvv_type)
    # Generate file riscv-vector.h
    with open("riscv-vector.h", "w") as riscv_vector_h_fp:
        riscv_vector_h_fp.write(build_builtins_head)
        for type_union in rvv_type.gen_builtins_type_union_code():
            riscv_vector_h_fp.write(type_union)
        for builtin_decl in rvv_builtins.gen_builtin_decls():
            riscv_vector_h_fp.write(builtin_decl)
        riscv_vector_h_fp.write(build_builtins_tail)
    rvv_type.gen_vector_type_def()
    rvv_type.gen_vector_seg_type_def(avlen=128)
    rvv_type.gen_seg_mode_iterators(avlen=128)
    rvv_type.gen_vector_seg_atype_def(avlen=128)
    rvv_builtins.gen_builtin_defs(seg_avlen=128)
    rvv_builtins.write_testsuite('../../testsuite/gcc.target/riscv/vector/')
    rvv_builtins.write_document('riscv-vector-doc')


if __name__ == "__main__":
    main()
